{"./":{"url":"./","title":"索引","keywords":"","body":"索引 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-07 20:23:20 "},"designpatterns/":{"url":"designpatterns/","title":"设计模式","keywords":"","body":"设计模式 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-07 20:23:20 "},"designpatterns/factory.html":{"url":"designpatterns/factory.html","title":"工厂","keywords":"","body":"简单工厂模式 简单工厂模式是指由一个工厂对象决定创建出哪一种产品类的实例，但它不属于23种设计模式。它适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。 示例 Calendar.getInstance()方法 LoggerFactory.getLogger()方法 缺点 工厂类的指责相对过重，不易于扩展过于复杂的产品结构。 工厂方法模式 工厂方法模式是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符合开闭原则。工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个产品的创建逻辑有区别的话，工厂的职责会变得越来越多，并不便于维护。根据单一职责原则我们将职能继续拆分，专人干专事。 适用场景 创建对象需要大量重复的代码 应用层不依赖于产品类实例如何被创建和实现等细节 一个类通过其子类来指定创建哪个对象 缺点 类的个数容易过多，增加复杂度 增加了系统的抽象性和理解难度 抽象工厂模式 抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无须指定它们具体的类。应用层不依赖于产品类实例如何被创建和实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使应用层不依赖于具体实现。 缺点 规定了所有可能被创建的产集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口 增加了系统的抽象性和理解难度 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-07 21:32:49 "},"designpatterns/singleton.html":{"url":"designpatterns/singleton.html","title":"单例","keywords":"","body":"单例 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-07 20:23:20 "},"concurrent.html":{"url":"concurrent.html","title":"并发","keywords":"","body":"并发 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-07 20:23:20 "},"oauth2/":{"url":"oauth2/","title":"Oauth2","keywords":"","body":"Oauth2 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-07 20:23:20 "},"oauth2/websecurityconfigureradapter-yu-resourceserverconfigureradapter.html":{"url":"oauth2/websecurityconfigureradapter-yu-resourceserverconfigureradapter.html","title":"WebSecurityConfigurerAdapter与ResourceServerConfigurerAdapter","keywords":"","body":"WebSecurityConfigurerAdapter与ResourceServerConfigurerAdapter 1.1、spring security的过滤器链 spring security自己有一个叫FilterChainProxy代理类，该类实现了servlet接口。FilterChainProxy内部有一个List filterChains,在spring 的体系里有个order值（int型）越小优先级越高，filterChains是一个依据order的降序集合，优先级高的在前面，而SecurityFilterChain是一个接口也是一个chain，每个chain里有若干个filter，在spring security里一个请求只会被一个filter chain进行处理，也就是spring security通过遍历filterChains这个集合时，只要找到能处理该请求（servlet-path匹配，即uri中去掉context-path的部分）的filter chain就不再进行其他的filter chain匹配。 private List filterChains; private List getFilters(HttpServletRequest request) { Iterator var2 = this.filterChains.iterator(); SecurityFilterChain chain; do { if (!var2.hasNext()) { return null; } chain = (SecurityFilterChain)var2.next(); } while(!chain.matches(request)); // 找到匹配的chain后终止循环 return chain.getFilters(); } 1.2、二者顺序 默认的WebSecurityConfigurerAdapter的order是100 @Order(100) public abstract class WebSecurityConfigurerAdapter 而ResourceServerConfigurerAdapter实现类的@EnableResourceServer里导入了ResourceServerConfiguration， @Import({ResourceServerConfiguration.class}) public @interface EnableResourceServer { 该类里定义了order为3 public class ResourceServerConfiguration extends WebSecurityConfigurerAdapter implements Ordered { private int order = 3; 所以ResourceServerConfigurerAdapter的实现类优先级比另外一个的更高，在请求匹配的情况下以它为准，而WebSecurityConfigurerAdapter的实现类会失效。 如果想让WebSecurityConfigurerAdapter比ResourceServerConfigurerAdapter优先级高的话，只须要让前者的@Order值比后者的@Order值更小就行了。 @Order(1) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { 每声明一个*Adapter的实现类，都会产生一个filterChain。前面讲到一个request（匹配url）只能被一个filterChain处理，所以有二个Adapter的时候，在请求都匹配的情况下，优先级较低的会失效。 1.3、二者同时生效 根本在于让不同的Adapter匹配不同request（url） 实现时将细粒度较粗的优先级设低 @EnableWebSecuritypublic class MultiHttpSecurityConfig { @Configuration @EnableResourceServer public static class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .antMatcher(\"/auth/**\") // 指定该Adapter只处理/auth/**的请求 .authorizeRequests() // 对该路径做更细的权限控制 .antMatchers(\"/admin/**\").hasAuthority(\"ROLE_ADMIN\") .antMatchers(\"/user/**\").hasAuthority(\"ROLE_USER\") .anyRequest().authenticated(); } } @Configuration public static class WebSecurityConfig extends WebSecurityConfigurerAdapter { protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() // 因为它的顺序在上面的Adapter之后，所以实际是对/auth/**外的所有请求做权限的控制 .antMatchers(\"/actutor/**\").permitAll( .antMatchers(\"/admin/**\").hasAuthority(\"ROLE_ADMIN\") .anyRequest() .authenticated(); } } } 1.4、Tips spring security集成Oauth2后有个默认的AuthorizationServerSecurityConfiguration，其order为0，该类是对/oauth/token、/oauth/token_key、/oauth/check_token三个url做处理的 protected void configure(HttpSecurity http) throws Exception { AuthorizationServerSecurityConfigurer configurer = new AuthorizationServerSecurityConfigurer(); FrameworkEndpointHandlerMapping handlerMapping = this.endpoints.oauth2EndpointHandlerMapping(); http.setSharedObject(FrameworkEndpointHandlerMapping.class, handlerMapping); this.configure(configurer); http.apply(configurer); String tokenEndpointPath = handlerMapping.getServletPath(\"/oauth/token\"); String tokenKeyPath = handlerMapping.getServletPath(\"/oauth/token_key\"); String checkTokenPath = handlerMapping.getServletPath(\"/oauth/check_token\"); if (!this.endpoints.getEndpointsConfigurer().isUserDetailsServiceOverride()) { UserDetailsService userDetailsService = (UserDetailsService)http.getSharedObject(UserDetailsService.class); this.endpoints.getEndpointsConfigurer().userDetailsService(userDetailsService); } // /oauth/token的权限写死为fullyAuthenticated // /oauth/token_key、/oauth/check_token的权限则是可配的，默认为denyAll，可在实现AuthorizationServerConfigurerAdapter的配置类中修改 ((RequestMatcherConfigurer)((HttpSecurity)((AuthorizedUrl)((AuthorizedUrl)((AuthorizedUrl)http.authorizeRequests().antMatchers(new String[]{tokenEndpointPath})).fullyAuthenticated().antMatchers(new String[]{tokenKeyPath})).access(configurer.getTokenKeyAccess()).antMatchers(new String[]{checkTokenPath})).access(configurer.getCheckTokenAccess()).and()).requestMatchers().antMatchers(new String[]{tokenEndpointPath, tokenKeyPath, checkTokenPath})).and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); http.setSharedObject(ClientDetailsService.class, this.clientDetailsService); } public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception { oauthServer .tokenKeyAccess(\"permitAll()\") .checkTokenAccess(\"isAuthenticated()\"); } } Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-07 20:23:20 "}}