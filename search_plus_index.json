{"./":{"url":"./","title":"索引","keywords":"","body":"索引 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:46:10 "},"algorithm/dataStructure.html":{"url":"algorithm/dataStructure.html","title":"数据结构","keywords":"","body":"散列表（哈希表） 一种Key-Value映射形式的存储结构，通过Key查找Value的时间复杂度接近于O (1)，因为其本质上是一个数组，通过哈希函数将Key转换成数组下标，不同的Key转换成的下标有可能是相同的，这种情况叫做哈希冲突，通过有如下两种方式解决： 开放寻址法 当冲突时，寻找一个其他的位置，若该位置还没有元素，则使用该位置，否则继续寻找，ThreaLocal就是这样 链表法 数组的每一个元素都是一个链表的头节点，当冲突时，将新的Value插入到链表尾部，JDK1.7的HashMap就是这样 链表 单向链表 每个节点包含存储的数据和指向下一个节点的指针next，第一个叫头节点，最后一个叫尾节点，尾节点的next指向null 双向链表 每个节点包含存储的数据和指向下一个节点的指针next，同时还有个指向前置节点的prev指针，除了尾节点的next指向null，头节点的prev也指向null 树 基本术语 祖先节点 沿树根到某一节点路径上的所有节点都是这个节点的祖先节点 子孙节点 某个节点子树中的所有节点都是这个节点的子孙节点 子节点 又称孩子节点 子树 节点下面一个子节点即为一个子树 节点的度 节点的子树个数 树的度 树的所有节点中最大的度 树的深度 根在1层，其他节点的层数是父节点的层数+1，最大的层数即为树的深度 边 除了根节点，每个节点都有一条通往上个节点的边，所以N个节点的树有N-1条边 二叉树 一种每个节点最多有2个孩子节点的树，一个叫左孩子，一个叫右孩子，有如下几个性质： 第k层的最大节点数为2的k-1次方 深度为k的树的最大节点数为2的k次方-1 若n0表示叶子节点的个数，n1表示度为1的节点的个数，n2表示度为2的节点的个数，则n0=n2+1 满二叉树 所有非叶子节点都有左右两个孩子节点，且所有叶子节点都在同一层 完全二叉树 对一个有n个节点的二叉树，按层级及从左到右的顺序编号，如果这个树的所有节点和同样深度的满二叉树的编号的节点位置相同，即为完全二叉树，如下图，从1到12节点，完全二叉树的节点位置和满二叉树一致，类似一种子集的概念 二叉查找树 又称二叉排序树，主要有如下几个性质： 若左子树不为空，则左子树上所有节点的值均小于根节点的值 若右子树不为空，则右子树上所有节点的值均大于根节点的值 左、右子树也都是二叉查找树 搜索节点的时间复杂度为O(logn) 二叉堆 本质上是一个完全二叉树，根节点称为堆顶，分为两种类型 最大堆 任何一个父节点的值都大于等于它的左右孩子节点的值 最小堆 任何一个父节点的值都小于等于它的左右孩子节点的值 二叉树的遍历 深度优先遍历 前序遍历 顺序为根节点，左子树，右子树 public static void DLR(TreeNode root) { System.out.println(root); DLR(root.getLeftChild()); DLR(root.getRightChild()); } 中序遍历 顺序为左子树，根节点，右子树 public static void DLR(TreeNode root) { DLR(root.getLeftChild()); System.out.println(root); DLR(root.getRightChild()); } 后序遍历 顺序为左子树，右子树，根节点 public static void DLR(TreeNode root) { DLR(root.getLeftChild()); DLR(root.getRightChild()); System.out.println(root); } 广度优先遍历 层序遍历 顺序为从根节点到叶子节点，从左至右 public static void levelTraversal(TreeNode root) { Queue queue = new LinkedList<>(); // 根节点入队 queue.offer(root); while (!queue.isEmpty()) { // 队首出队 TreeNode node = queue.poll(); System.out.println(node); if (node.getLeftChild() != null) { // 左孩子入队 queue.offer(node.getLeftChild()); } if (node.getRightChild() != null) { // 右孩子入队 queue.offer(node.getRightChild()); } } } 优先队列 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-12-23 23:24:03 "},"algorithm/mergeSortedList.html":{"url":"algorithm/mergeSortedList.html","title":"合并有序链表","keywords":"","body":"合并有序链表 LeetCode第21题 非递归解法 时间复杂度：O(m+n)，m和n分别为两个链表的长度，每次循环只会有两个链表中的某一个元素被放入合并链表，因此最多有m+n次循环 空间复杂度：O(1) public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 若某个链表为空，则直接返回另一个链表 if (l1 == null) { return l2; } if (l2 == null) { return l1; } // 定义一个哑结点 ListNode dummy = new ListNode(0); // 定义一个指针，该指针永远指向结果链表的尾节点 ListNode cur = dummy; // 遍历两个链表 while(l1 != null && l2 != null) { // 取较小的那个值作为新节点添加 if (l1.val > l2.val) { cur.next = new ListNode(l2.val); l2 = l2.next; } else { cur.next = new ListNode(l1.val); l1 = l1.next; } cur = cur.next; } // 剩下不为空的节点直接添加 cur.next = l1 != null ? l1 : l2; return dummy.next; } 该实现有几行比较关键 ListNode cur = dummy; ... cur = cur.next 1、开始时只有一个哑结点，cur指向的是结果链表的尾节点，只是因为结果链表只有一个节点，所以看似指向哑结点 2、当添加一个较小的节点后，cur指向了新的尾节点 3、cur不断的指向尾节点，是为了cur.next = new ListNode(...);能不断的添加节点至结果链表 递归解法 时间复杂度：O(m+n)，其中m和n分别为两个链表的长度，因为每次递归都会去掉两个链表中某个链表的头节点（直到至少有一个链表为空），函数 mergeTwoList最多把每个节点都递归到 空间复杂度：O(m+n)，其中m和n分别为两个链表的长度，递归需要消耗栈空间，栈空间的大小取决于递归调用的深度，结束递归时mergeTwoLists函数最多调用m+n次 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 若某个链表为空，则直接返回另一个链表 if (l1 == null) { return l2; } if (l2 == null) { return l1; } if (l1.val Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-01-26 11:32:05 "},"algorithm/oddEvenList.html":{"url":"algorithm/oddEvenList.html","title":"奇偶链表","keywords":"","body":"奇偶链表 LeetCode第328题 LeetCode第86题 分隔链表再合并成结果链表 时间复杂度：O(N) 空间复杂度：O(1) public ListNode oddEvenList(ListNode head) { // 没有节点或只有一个节点的链表，直接返回 if (head == null || head.next == null) { return head; } // 奇数链表哑结点 ListNode odd = new ListNode(0); // 奇数链表指针 ListNode oddCur = odd; // 偶数链表哑结点 ListNode even = new ListNode(0); // 偶数链表指针 ListNode evenCur = even; int index = 1; // 遍历链表 while (head != null) { if (index % 2 != 0) { // 将节点加入奇数链表 oddCur.next = head; // 奇数链表指针后移 oddCur = oddCur.next; } else { // 将节点加入偶数链表 evenCur.next = head; // 偶数链表指针后移 evenCur = evenCur.next; } index++; head = head.next; } // 偶数链表尾节点后面接个null evenCur.next = null; // 将偶数链表接到奇数链表后面 oddCur.next = even.next; return odd.next; } Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-01-26 11:45:49 "},"algorithm/copyList.html":{"url":"algorithm/copyList.html","title":"复制带随机指针的链表","keywords":"","body":"复制带随机指针的链表 LeetCode第138题 剑指offer第35题 public Node copyRandomList(Node head) { if (head == null) { return null; } // 复制节点N‘到N后面，此时节点的random都为null Node cur = head; while (cur != null) { Node node = new Node(cur.val); node.next = cur.next; cur.next = node; cur = cur.next.next; } // 给复制的节点的random赋值，值为原节点的random的复制节点 cur = head; while (cur != null) { if (cur.random != null) { cur.next.random = cur.random.next; } cur = cur.next.next; } // 拆分链表，还原原来的head，组装要返回的复制链表 cur = head; Node resHead = head.next; Node res = head.next; while (cur != null) { cur.next = cur.next.next; cur = cur.next; if (res.next != null) { res.next = res.next.next; res = res.next; } } return resHead; } Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-07 14:05:23 "},"designpatterns/creational/factory.html":{"url":"designpatterns/creational/factory.html","title":"工厂","keywords":"","body":"简单工厂模式 又称静态工厂方法模式，工厂类封装new对象的细节，使用者通过传参给工厂类来获得相应对象。 组成： 工厂类角色（一个）：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品。 抽象产品角色（一个）：它一般是具体产品继承的父类或者实现的接口。 具体产品角色（多个）：工厂类所创建的对象就是此角色的实例，在java中由一个具体类实现。 设计原则分析 每增加一种产品，创建一个具体产品角色，产品层面不违背开闭原则，但需要修改工厂类中创建产品的逻辑，工厂层面违背了开闭原则。且随着产品越来越多，工厂职责越来越重，违背了单一职责原则。 如： // 使用者 Logger LOGGER = LoggerFactory.getLogger(WebLogController.class); public static Logger getLogger(Class clazz) { Logger logger = getLogger(clazz.getName()); if (DETECT_LOGGER_NAME_MISMATCH) { Class autoComputedCallingClass = Util.getCallingClass(); if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) { Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(), autoComputedCallingClass.getName())); Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\"); } } return logger; } public static Logger getLogger(String name) { ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name); } // 使用者 Calendar calendar = Calendar.getInstance(); public static Calendar getInstance() { return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT)); } private static Calendar createCalendar(TimeZone zone, Locale aLocale) { CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) { try { return provider.getInstance(zone, aLocale); } catch (IllegalArgumentException iae) { // fall back to the default instantiation } } Calendar cal = null; if (aLocale.hasExtensions()) { String caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) { switch (caltype) { case \"buddhist\": cal = new BuddhistCalendar(zone, aLocale); break; case \"japanese\": cal = new JapaneseImperialCalendar(zone, aLocale); break; case \"gregory\": cal = new GregorianCalendar(zone, aLocale); break; } } } if (cal == null) { // If no known calendar type is explicitly specified, // perform the traditional way to create a Calendar: // create a BuddhistCalendar for th_TH locale, // a JapaneseImperialCalendar for ja_JP_JP locale, or // a GregorianCalendar for any other locales. // NOTE: The language, country and variant strings are interned. if (aLocale.getLanguage() == \"th\" && aLocale.getCountry() == \"TH\") { cal = new BuddhistCalendar(zone, aLocale); } else if (aLocale.getVariant() == \"JP\" && aLocale.getLanguage() == \"ja\" && aLocale.getCountry() == \"JP\") { cal = new JapaneseImperialCalendar(zone, aLocale); } else { cal = new GregorianCalendar(zone, aLocale); } } return cal; } 工厂方法模式 工厂方法模式简单来讲就是简单工厂模式里集中在工厂类上的压力由工厂方法模式里不同的工厂子类来分担。 组成 抽象工厂角色（一个）： 这是本模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在java中它由抽象类或者接口来实现。 具体工厂角色（多个）：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象。 抽象产品角色（一个）：它是具体产品继承的父类或者是实现的接口，在java中一般由抽象类或者接口来实现。 具体产品角色（多个）：具体工厂角色所创建的对象就是此角色的实例，在java中由具体的类来实现。 设计原则分析 当有新的具体产品产生时，只要按照抽象产品角色、抽象工厂角色提供的规则来生成具体产品角色和具体工厂角色，而不必去修改任何已有的代码。可以看出产品和工厂层面都是符合开闭原则的。每个具体工厂角色只负责创建对应的具体产品角色，不违背单一职责原则。 抽象工厂模式 多个抽象产品角色，每个抽象产品角色有多个具体产品角色的情况下，由一个具体工厂角色负责创建一系列相关或相互依赖的具体产品角色，而无需创建多个具体工厂角色。 组成 抽象工厂角色（一个）： 这是本模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在java中它由抽象类或者接口来实现。 具体工厂角色（多个）：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象。 抽象产品角色（多个）：它是具体产品继承的父类或者是实现的接口，在java中一般由抽象类或者接口来实现。 具体产品角色（多个）：具体工厂角色所创建的对象就是此角色的实例，在java中由具体的类来实现。 比如空调这个抽象产品分为美的空调，海尔空调，格力空调，冰箱这个抽象产品分为美的冰箱，海尔冰箱，格力冰箱，洗衣机这个抽象产品分为美的洗衣机，海尔洗衣机，格力洗衣机，像美的空调，美的冰箱，美的洗衣机都属于美的品牌，那么就由一个美的工厂来负责生产这三个产品，而不需要美的空调工厂，美的冰箱工厂，美的洗衣机工厂3个工厂来处理。 设计原则分析 如果加入了一个新的抽象产品，那么从抽象工厂角色到具体工厂角色都要调整，违背了开闭原则。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-21 10:31:17 "},"designpatterns/creational/singleton.html":{"url":"designpatterns/creational/singleton.html","title":"单例","keywords":"","body":"饿汉式单例 饿汉式单例是在类加载的时候就立即创建对象，绝对线程安全，在线程还没出现以前就实例化了，不会存在访问安全问题，优点是没有锁及复杂逻辑，效率高，缺点是不管使不使用都占着空间，浪费内存。 public class Singleton { private static final Singleton singleton = new Singleton(); private Singleton() {} public static Singleton getInstance() { return singleton; } } public class Singleton { private static Singleton singleton = null; static { singleton = new Singleton(); } private Singleton() {} public static Singleton getInstance() { return singleton; } } 懒汉式单例 懒汉式单例是在获取实例的方法被调用时才创建对象。 public class Singleton { private static Singleton singleton = null; private Singleton() {} // 在线程数量比较多情况下，会导致大批量线程出现阻塞，从而导致程序运行性能大幅下降 public synchronized static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } public class Singleton { private static volatile Singleton singleton = null; private Singleton() {} // 双重检查锁 public static Singleton getInstance() { if (singleton == null) { synchronized (singleton.getClass()) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } public class Singleton { private Singleton() {} public static final Singleton getInstance() { // 调用时才会初始化内部类 return InnerSingleton.singleton; } // 静态内部类 // 这种形式没有饿汉式的内存浪费，也没有synchronized的性能问题 private static class InnerSingleton { private static final Singleton singleton = new Singleton(); } } 破坏单例 反射 Class clazz = Singleton.class; // 通过反射拿到私有的构造方法 Constructor c = clazz.getDeclaredConstructor(null); // 强制访问 c.setAccessible(true); // 暴力初始化 Object o1 = c.newInstance(); Object o2 = Singleton.getInstance(); System.out.println(o1 == o2); // false 解决方法：在单例的构造方法中加以限制： private Singleton() { // 此处的判断作用有： // 1、若不加判断直接抛出异常，则内部类中无法创建实例 // 2、若如上面的代码，在调用单例类提供的获取实例方法之前先暴力初始化， // if里的判断调用了内部类，仍会先初始化内部类， // 内部类在创建实例时到此判断，此时InnerSingleton.singleton为null，创建实例， // 接着继续暴力初始化在此处的判断，InnerSingleton.singleton不为null， // 所以此处InnerSingleton.singleton为null只有一种情况：初始化内部类时创建Singleton实例 if (InnerSingleton.singleton != null) { throw new RuntimeException(\"no permition to new instance\"); } } 序列化与反序列化 Singleton s1 = null; Singleton s2 = Singleton.getInstance(); FileOutputStream fos = new FileOutputStream(\"Singleton.obj\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(s2); oos.flush(); oos.close(); FileInputStream fis = new FileInputStream(\"Singleton.obj\"); ObjectInputStream ois = new ObjectInputStream(fis); s1 = (Singleton)ois.readObject(); ois.close(); System.out.println(s1 == s2); // false 解决方法：在单例类中增加 readResolve()方法 private Singleton readResolve() { return InnerSingleton.singleton; } 至此一个完美的单例诞生： public class Singleton implements Serializable { private Singleton() { // 防止反射破解 if (InnerSingleton.singleton != null) { throw new RuntimeException(\"no permition to new instance\"); } } public static final Singleton getInstance() { // 调用时才会初始化内部类 return InnerSingleton.singleton; } // 静态内部类 // 这种形式没有饿汉式的内存浪费，也没有synchronized的性能问题 private static class InnerSingleton { private static final Singleton singleton = new Singleton(); } // 防止序列化与反序列化破解 private Singleton readResolve() { return InnerSingleton.singleton; } } 原理： ObjectInputStream ois = new ObjectInputStream(fis); s1 = (Singleton)ois.readObject(); public final Object readObject() throws IOException, ClassNotFoundException { if (enableOverride) { return readObjectOverride(); } // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) { throw ex; } if (depth == 0) { vlist.doCallbacks(); } return obj; } finally { passHandle = outerHandle; if (closed && depth == 0) { clear(); } } } private Object readObject0(boolean unshared) throws IOException { ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); ... } private Object readOrdinaryObject(boolean unshared) throws IOException { if (bin.readByte() != TC_OBJECT) { throw new InternalError(); } ObjectStreamClass desc = readClassDesc(false); desc.checkDeserialize(); Class cl = desc.forClass(); if (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) { throw new InvalidClassException(\"invalid class descriptor\"); } Object obj; try { // 就是判断一下构造方法是否为空,只要有无参构造方法就会实例化 obj = desc.isInstantiable() ? desc.newInstance() : null; } catch (Exception ex) { throw (IOException) new InvalidClassException( desc.forClass().getName(), \"unable to create instance\").initCause(ex); } passHandle = handles.assign(unshared ? unsharedMarker : obj); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) { handles.markException(passHandle, resolveEx); } if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } handles.finish(passHandle); if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) // 找到了无参的readResolve() { Object rep = desc.invokeReadResolve(obj); if (unshared && rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } // obj被重新赋值为反射调用readResolve方法得到的返回值 handles.setObject(passHandle, obj = rep); } } return obj; } boolean isInstantiable() { requireInitialized(); return (cons != null); } boolean hasReadResolveMethod() { requireInitialized(); return (readResolveMethod != null); } // ObjectStreamClass(final Class cl)方法中赋值 // 通过反射找到一个无参的readResolve()方法 readResolveMethod = getInheritableMethod( cl, \"readResolve\", null, Object.class); Object invokeReadResolve(Object obj) throws IOException, UnsupportedOperationException { requireInitialized(); if (readResolveMethod != null) { try { return readResolveMethod.invoke(obj, (Object[]) null); } catch (InvocationTargetException ex) { Throwable th = ex.getTargetException(); if (th instanceof ObjectStreamException) { throw (ObjectStreamException) th; } else { throwMiscException(th); throw new InternalError(th); // never reached } } catch (IllegalAccessException ex) { // should not occur, as access checks have been suppressed throw new InternalError(ex); } } else { throw new UnsupportedOperationException(); } } 通过以上的源码分析可以看出，虽然增加 readResolve()方法返回实例，解决了单例被破坏的问题，但是，实际上还是实例化了两次，只不过第一次实例化的对象没有被返回而已。如果创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大，登记式单例将解决这个问题。 登记（注册）式单例 就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。 容器缓存 public class Singleton { public static final Map container = new ConcurrentHashMap<>(); private Singleton(){} public static Object getInstance(String className) { if (!container.containsKey(className)) { synchronized (Singleton.class) { if (!container.containsKey(className)) { try { container.put(className, Class.forName(className).newInstance()); } catch (InstantiationException|IllegalAccessException|ClassNotFoundException e) { e.printStackTrace(); } } } } return container.get(className); } } 枚举登记 public enum Singleton { // 枚举类构造方法默认私有化 // INSTANCE默认为static final INSTANCE; // Singleton.INSTANCE就是Singleton的唯一实例 } 通过工具jad反编译后 public final class Singleton extends Enum { public static Singleton[] values() { return (Singleton[])$VALUES.clone(); } public static Singleton valueOf(String name) { return (Singleton)Enum.valueOf(com/example/demo/Singleton, name); } private Singleton(String s, int i) { super(s, i); } public static final Singleton INSTANCE; private static final Singleton $VALUES[]; static { // 静态代码块中赋值，属于饿汉式 INSTANCE = new Singleton(\"INSTANCE\", 0); $VALUES = (new Singleton[] { INSTANCE }); } } 那么能否通过反射破解呢 public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); } } // 如果是枚举类型直接抛异常 if ((clazz.getModifiers() & Modifier.ENUM) != 0) throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) { ca = acquireConstructorAccessor(); } @SuppressWarnings(\"unchecked\") T inst = (T) ca.newInstance(initargs); return inst; } 能否通过序列化与反序列化破解呢 private Object readObject0(boolean unshared) throws IOException { ... case TC_ENUM: return checkResolve(readEnum(unshared)); ... } private Enum readEnum(boolean unshared) throws IOException { if (bin.readByte() != TC_ENUM) { throw new InternalError(); } ObjectStreamClass desc = readClassDesc(false); if (!desc.isEnum()) { throw new InvalidClassException(\"non-enum class: \" + desc); } int enumHandle = handles.assign(unshared ? unsharedMarker : null); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) { handles.markException(enumHandle, resolveEx); } String name = readString(false); Enum result = null; Class cl = desc.forClass(); if (cl != null) { try { @SuppressWarnings(\"unchecked\") // 通过 Class 对象和类名找到一个唯一的枚举对象,没有创建新的实例 Enum en = Enum.valueOf((Class)cl, name); result = en; } catch (IllegalArgumentException ex) { throw (IOException) new InvalidObjectException( \"enum constant \" + name + \" does not exist in \" + cl).initCause(ex); } if (!unshared) { handles.setObject(enumHandle, result); } } handles.finish(enumHandle); passHandle = enumHandle; return result; } 附：双重检查volatile关键字的必要性 singleton = new Singleton(); 创建了一个对象。这一行代码可以分解为如下的3行伪代码： memory = allocate(); // 1：分配对象的内存空间 ctorInstance(memory); // 2：初始化对象 instance = memory; // 3：设置instance指向刚分配的内存地址 上面3行伪代码中的2和3之间，可能会被重排序（在一些JIT编译器上，这种重排序是真实发生的）。2和3之间重排序之后的执行时序如下： memory = allocate(); // 1：分配对象的内存空间 instance = memory; // 3：设置instance指向刚分配的内存地址 // 注意，此时对象还没有被初始化！ ctorInstance(memory); // 2：初始化对象 根据《The Java Language Specification,Java SE 7 Edition》（后文简称为Java语言规范），所有线程在执行Java程序时必须要遵守intra-thread semantics。intra-thread semantics保证重排序不会改变单线程内的程序执行结果。换句话说，intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。上面3行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反intra-thread semantics。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。如下图所示，只要保证2排在4的前面，即使2和3之间重排序了，也不会违反intra-thread semantics。 如下的执行时序，这里A2和A3虽然重排序了，但Java内存模型的intra-thread semantics将确保A2一定会排在A4前面执行。因此，线程A的intra-thread semantics没有改变，但A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-01-27 15:16:59 "},"designpatterns/creational/prototype.html":{"url":"designpatterns/creational/prototype.html","title":"原型","keywords":"","body":"概念 核心在于拷贝原型对象。当对象的构建过程比较耗时时，以一个已存在的对象为原型，基于内存二进制流进行拷贝，无需再经历耗时的对象初始化过程（调用构造函数），性能提升许多。 适用场景 类初始化消耗资源较多 new产生的一个对象需要非常繁琐的过程（new之后需要初始化一些数据） 构造函数复杂 循环体中产生大量对象时 组成 抽象原型（Prototype）：规定拷贝方法 public interface IPrototype { T clone(); } 具体原型（Concrete Prototype）：被拷贝的对象 @Data public class ConcretePrototype implements IPrototype { private int age; private String name; @Override public ConcretePrototype clone() { ConcretePrototype concretePrototype = new ConcretePrototype(); concretePrototype.setAge(this.age); concretePrototype.setName(this.name); return concretePrototype; } } 客户端（Client）：通过拷贝的方式创建对象 public static void main(String[] args) { // 创建原型对象 ConcretePrototype prototype = new ConcretePrototype(); prototype.setAge(18); prototype.setName(\"Tom\"); // 拷贝原型对象 ConcretePrototype cloneType = prototype.clone(); } Object中的clone()与Cloneable接口 以上是原型模式最基本的写法，实际上抽象原型不需要自己定义，所有类的父类Object中有一个native方法clone()，JDK提供了一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在jvm中，只有实现了这个接口的类才可以通过clone()被拷贝，否则在运行时会抛出CloneNotSupportedException异常。基于此，具体原型的实现如下： @Data public class ConcretePrototype implements Cloneable { private int age; private String name; @Override public ConcretePrototype clone() { try { return (ConcretePrototype)super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } 深克隆与浅克隆 浅克隆 以上具体原型对象中的属性只是基本数据类型，但如果是引用类型呢，比如List，会发现在克隆对象的list中新增一个元素，原型对象里的list也会跟着新增，显然对于引用类型的对象，并未在内存中开辟一块新的空间，并拷贝数据，原型对象与克隆对象的引用类型的变量指向的是同一个内存地址，这就是浅克隆。或者说克隆对象的改变会导致原型对象的改变就是浅克隆。因此对基础数据类型及它们的封装类和String的克隆都是深克隆。 深克隆 实现引用类型的对象的实际拷贝，原型对象与克隆对象完全独立。 序列化 @Data public class ConcretePrototype implements Cloneable { private int age; private String name; @Override public ConcretePrototype clone() { try { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (ConcretePrototype)ois.readObject(); } catch (Exception e) { e.printStackTrace(); return null; } } } JSON 手动复制 原型模式与单例模式 原型模式与单例模式是互相对立的。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-02 17:17:36 "},"designpatterns/creational/builder.html":{"url":"designpatterns/creational/builder.html","title":"建造者","keywords":"","body":"适用场景 创建对象需要很多步骤，但是步骤的顺序不一定固定 对象有非常复杂的内部结构（很多属性） 对象的很多参数都有默认值 组成 产品（Product）：要创建的对象 @Data public class User { private String name; private Integer age; private String email; private String phone; private String role; private String idCard; private String address; private String company; } 建造者抽象（Builder）：建造者的抽象类，规范产品对象的各个组成部分的建造，由子类实现具体的建造过程 public interface IBuilder { T build(); } 建造者（Concrete Builder）：具体的Builder类，根据不同的业务逻辑，具体化对象的各个组成部分的创建 public class UserBuilder implements IBuilder { private User user = new User(); public UserBuilder name(String name) { user.setName(name); return this; } public UserBuilder age(Integer age) { user.setAge(age); return this; } ... public User build() { return user; } } 调用者（Director）：调用具体的建造者，负责对象各部分完整创建或按某种顺序创建 User user = new UserBuilder() .name(\"zhangsan\") .age(20) .role(\"admin\") .company(\"ALI\") .email(\"test@test.com.cn\") .phone(\"1811111111\") .idCard(\"32123213123123123\") .address(\"某某路2号\") .build(); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-06 10:48:20 "},"designpatterns/structure/adapter.html":{"url":"designpatterns/structure/adapter.html","title":"适配器","keywords":"","body":"概念 又叫变压器模式，通过一个中间层将一个与客户端的期望不匹配的接口转换为匹配的另一个接口 组成 以家用的220V交流电需要转化为手机充电用的5V直流电为例 目标角色（Target）：期望接口 public interface DC5 { int outputDC5V(); } 源角色（Adaptee）：内容满足需求但不匹配的接口 public class AC220 { public int outputAC220V() { return 220; } } 适配器（Adapter）：将源角色转换为目标角色的实例 类适配器 让Adapter继承Adaptee并实现Target，在具体的实现方法中做转换 public class PowerAdapter extends AC220 implements DC5 { @Override public int output5V() { return super.outputAC220V() / 44; } } 对象适配器 让Adapter实现Target并内部持有Adaptee的引用，在Target接口规定的方法内转换Adaptee public class PowerAdapter implements DC5 { private AC220 ac220; public PowerAdapter(AC220 ac220) { this.ac220 = ac220; } @Override public int output5V() { return ac220.outputAC220V() / 44; } } 接口适配器 当不需要全部实现接口提供的方法时，可先设计一个抽象类（适配器）实现接口，并为该接口中每个方法提供一个默认实现/空实现，那么原先需要实现该接口的类改为继承抽象类同时可有选择的覆盖父类的某些方法来实现需求，匿名内部类是一种常见的形式 public interface InterfaceA { void metho1(); void metho2(); void metho3(); void metho4(); void metho5(); } public abstract class Adapter implements InterfaceA { @Override public void metho1() {} @Override public void metho2() {} @Override public void metho3() {} @Override public void metho4() {} @Override public void metho5() {} } Adapter adapter = new Adapter() { @Override public void method1() { System.out.println(\"\"); } }; adapter.method1(); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-08-17 19:14:40 "},"designpatterns/structure/decorator.html":{"url":"designpatterns/structure/decorator.html","title":"装饰者","keywords":"","body":"概念 在不改变原有对象的基础上，将功能附加到对象上，透明且动态的扩展类的功能。 组成 抽象组件（Component）：一个接口/抽象类，充当被装饰类的原始对象，规定了被装饰对象的行为。 public interface Cake { String getType(); int getPrice(); } 具体组件（Concrete Component）：实现/继承Component的一个具体对象，也是被装饰对象。 public class BaseCake implements Cake { @Override public String getType() { return \"普通蛋糕\"; } @Override public int getPrice() { return 20; } } 抽象装饰器（Decorator）：Concrete Component的装饰器，一般是一个抽象类，有一个Component类型的成员变量，在构造函数中赋值，强制其子类按其构造方式接收一个Component，如果不需要实现许多装饰器，可以省略该类。 public abstract class CakeDecorator implements Cake { private Cake cake; public CakeDecorator(Cake cake) { this.cake = cake; } @Override public String getType() { return cake.getType(); } @Override public int getPrice() { return cake.getPrice(); } } 具体装饰器（Concrete Decorator）：继承Decorator类，扩展Component的功能。 public class FruitCakeDecorator extends CakeDecorator { public FruitCakeDecorator(Cake cake) { super(cake); } @Override public String getType() { return super.getType() + \"水果\"; } @Override public int getPrice() { return super.getPrice() + 10; } } public class IceCreamCakeDecorator extends CakeDecorator { public IceCreamCakeDecorator(Cake cake) { super(cake); } @Override public String getType() { return super.getType() + \"冰激凌\"; } @Override public int getPrice() { return super.getPrice() + 15; } } 调用示例 Cake cake = new BaseCake(); System.err.println(cake.getType() + \":\" + cake.getPrice()); // 普通蛋糕:20 cake = new IceCreamCakeDecorator(cake); System.err.println(cake.getType() + \":\" + cake.getPrice()); // 普通蛋糕+冰淇淋:35 cake = new FruitCakeDecorator(cake); System.err.println(cake.getType() + \":\" + cake.getPrice()); // 普通蛋糕+冰淇淋+水果:45 与继承的区别 如果是继承，要满足以上场景需要冰淇淋蛋糕，冰淇淋水果蛋糕两个子类，如果这时候需要个水果蛋糕，就得加一个子类，对于普通蛋糕上可扩展项越多，子类将会成几何数增多，而装饰器与扩展项的关系则是1对1。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-10 18:11:56 "},"designpatterns/structure/proxy.html":{"url":"designpatterns/structure/proxy.html","title":"代理","keywords":"","body":"组成 抽象主题：声明方法，由真实主题与代理实现具体逻辑，是接口/抽象类 public interface ISubject { void request(); } 真实主题：被代理类，在实现抽象主题声明的方法里做了具体的逻辑处理 public class RealSubject implements ISubject { public void request() { System.out.println(\"real service is called.\"); } } 代理主题：代理类，持有真实主题的引用，在实现抽象主题声明的方法时，在真实主题的逻辑处理前后增加一些处理逻辑 public class Proxy implements ISubject { private ISubject subject; public Proxy(ISubject subject) { this.subject = subject; } public void request() { before(); subject.request(); after(); } public void before() { System.out.println(\"called before request().\"); } public void after() { System.out.println(\"called after request().\"); } } 静态代理 Proxy proxy = new Proxy(new RealSubject()); proxy.request(); 如上的实现方式便是静态代理，通常只代理一个明确的类 动态代理 JDK代理 示例 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class JdkProxy implements InvocationHandler { private ISubject target; public ISubject getInstance(ISubject target) { this.target = target; Class clazz = target.getClass(); return (ISubject) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(),this); } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { before(); Object result = method.invoke(this.target, args); after(); return result; } public void before() { System.out.println(\"called before request().\"); } public void after() { System.out.println(\"called after request().\"); } } JdkProxy proxy = new JdkProxy(); ISubject subject = proxy.getInstance(new RealSubject()); subject.request(); 原理 通过字节码重组，重新生成对象(JDK有一个规范，classpath下$开头的.class文件都是自动生成的)来代替原始的被代理对象，新的对象继承了Proxy类并实现了ISubject接口，同时重写了request等方法，在静态块中用反射获取了被代理对象的所有方法且保存了它们的引用，在重写的方法中用反射调用被代理对象的方法 获取被代理对象的引用，并通过反射获取其所有接口 重新生成一个新的实现了被代理对象所有接口的类 编译成.class文件并加载到JVM中 import java.lang.reflect.*; public final class $Proxy0 extends Proxy implements ISubject { public $Proxy0(InvocationHandler invocationhandler) { super(invocationhandler); } public final boolean equals(Object obj) { try { return ((Boolean)super.h.invoke(this, m1, new Object[] {obj})).booleanValue(); } catch(Error _ex) { } catch(Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final void request() { try { super.h.invoke(this, m3, null); return; } catch(Error _ex) { } catch(Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final String toString() { try { return (String)super.h.invoke(this, m2, null); } catch(Error _ex) { } catch(Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final int hashCode() { try { return ((Integer)super.h.invoke(this, m0, null)).intValue(); } catch(Error _ex) { } catch(Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } private static Method m1; private static Method m3; private static Method m2; private static Method m0; static { try { m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] {Class.forName(\"java.lang.Object\")}); m3 = Class.forName(\"com.learn.designpatterns.proxy.RealSubject\").getMethod(\"request\", new Class[0]); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); } catch(NoSuchMethodException nosuchmethodexception) { throw new NoSuchMethodError(nosuchmethodexception.getMessage()); } catch(ClassNotFoundException classnotfoundexception) { throw new NoClassDefFoundError(classnotfoundexception.getMessage()); } } } Cglib代理 被代理对象不需要实现接口,会忽略被代理对象final修饰的方法， 示例 import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CglibProxy implements MethodInterceptor { public Object getInstance(Class clazz) throws Exception { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); } public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { //业务的增强 before(); Object obj = methodProxy.invokeSuper(o,objects); after(); return obj; } public void before() { System.out.println(\"called before request().\"); } public void after() { System.out.println(\"called after request().\"); } } RealSubject subject = (RealSubject)new CglibProxy().getInstance(RealSubject.class); subject.request(); 原理 在new CglibProxy前添加System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/Users/cw/desktop/cglib_proxy_class/\");到cglib_proxy_class目录下可以看到cglib重新生成了3个对象，其中一个对象继承了被代理类即代理类，另外两个继承了FastClass类，这两个不是跟代理类一起生成的，而是在第一次执行MethodProxy的invoke()或 invokeSuper()方法时生成的。 CGLib执行代理方法的效率之所以比JDK的高，是因为CGlib采用了 FastClass机制：为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法分配一个index(int类型，供FastClass直接定位要调用的方法并直接进行调用)，省去了反射调用，所以调用效率比JDK代理通过反射调用高。 import java.lang.reflect.Method; import net.sf.cglib.core.ReflectUtils; import net.sf.cglib.core.Signature; import net.sf.cglib.proxy.*; public class RealSubject$$EnhancerByCGLIB$$3feeb52a extends RealSubject implements Factor { ... // 代理方法(methodProxy.invokeSuper()方法会调用) final void CGLIB$request$0() { super.request(); } //被代理方法(methodProxy.invoke()方法会调用，这就是为什么在拦截器中调用 methodProxy.invoke 会发生死循环，一直在调用拦截器） public final void request() { MethodInterceptor var10000 = this.CGLIB$CALLBACK_0; if (this.CGLIB$CALLBACK_0 == null) { CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_0; } if (var10000 != null) { var10000.intercept(this, CGLIB$request$0$Method, CGLIB$emptyArgs, CGLIB$request$0$Proxy); } else { super.request(); } } ... } CGLib和JDK动态代理对比 JDK动态代理实现了被代理对象的接口，CGLib代理继承了被代理对象 JDK动态代理和CGLib代理都在运行期生成字节码，JDK动态代理直接写Class 字节码，CGLib代理使用ASM框架写Class字节码，CGlib代理实现更复杂，生成代理类比JDK动态代理效率低 JDK动态代理调用代理方法是通过反射机制调用的，CGLib代理是通过 FastClass机制直接调用方法的，CGLib代理的执行效率更高 静态代理和动态代理的区别 对于静态代理，如果被代理类增加了新的方法，代理类需要同步增加，违反了开闭原则 动态代理采用在运行时动态生成代码的方式，没有对被代理类扩展的限制，遵循开闭原则 若动态代理要对目标类的增强逻辑进行扩展，结合策略模式，只需要新增策略类便可，无需修改代理类的代码 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-06-03 17:06:45 "},"designpatterns/structure/composite.html":{"url":"designpatterns/structure/composite.html","title":"组合","keywords":"","body":"概念 将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口表示，使得客户端无需辨别是哪种节点，直接操作。 组成 抽象根节点： 定义各层次共有的方法和属性 树枝节点：定义自身行为，存储子节点 叶子节点：层次遍历的最小单位 透明式 安全式 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-04-21 18:29:34 "},"designpatterns/structure/bridge.html":{"url":"designpatterns/structure/bridge.html","title":"桥接","keywords":"","body":"桥接 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:38:22 "},"designpatterns/structure/flyweight.html":{"url":"designpatterns/structure/flyweight.html","title":"享元","keywords":"","body":"概念 又称为轻量级模式，是对象池的一种实现。把对象的状态分为内部状态和外部状态，通过共享不变的部分，达到减少对象数量及节约内存的目的。 内部状态与外部状态 内部状态 对象内部不变的属性，比如 需要缓冲池：数据库连接对象中的用户名、密码、地址、驱动 系统中有大量相似的对象：一张票的出发地，目的地，耗时 外部状态 对象会产生变化的属性，比如 需要缓冲池：数据库连接对象中的可以使用，还是尚未被释放 系统中有大量相似的对象：一张票的数量，价格 组成 抽象享元：定义行为的一个接口或抽象类 具体享元：实现抽象享元的具体行为 享元工厂：维护享元对象池（通过数组或集合类） 应用场景 系统中有大量相似对象 需要缓冲池 案例 在源码中的应用 String 参考String常量池 Integer valueOf()做了一个判断，如果入参的值在-128至127之间，则从缓存中取值，否则新建对象，因为这个数据范围内数字是使用最频繁的，为了节省频繁创建对象带来的内存消耗，这里用享元模式来提高性能，同理，Long也是。 private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k = 127; } private IntegerCache() {} } public static Integer valueOf(int i) { if (i >= IntegerCache.low && i Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-04-26 17:49:05 "},"designpatterns/behavioral/strategy.html":{"url":"designpatterns/behavioral/strategy.html","title":"策略","keywords":"","body":"概念 又叫政策模式，用继承和多态解决在同一行为在不同场景下的不同实现，避免了if/else或switch所带来的复杂和臃肿 适用场景 针对同一类型问题，有多种处理方式，且每一种都能独立解决问题 算法需要自由切换且只取其中一种的场景 组成 抽象策略角色（IStrategy）：规定策略或算法的行为 public interface IPayStrategy { void pay(); } 具体策略角色（ConcreteStrategy）：具体的策略或算法实现 public class WeChatPayStrategy implements IPayStrategy { @Override public void pay() { System.out.println(\"微信支付\"); } } public class AliPayStrategy implements IPayStrategy { @Override public void pay() { System.out.println(\"支付宝支付\"); } } public class BankPayStrategy implements IPayStrategy { @Override public void pay() { System.out.println(\"银行支付\"); } } 上下文角色（Context）：用来操作策略或算法，屏蔽客户端对策略或算法的直接访问，封装可能存在的变化，一般结合工厂与单例 public class PayFactory { private static Map map = new HashMap<>(); static { map.put(\"wechat\", new WeChatPayStrategy()); map.put(\"ali\", new AliPayStrategy()); map.put(\"bank\", new BankStrategy()); } public static IPayStrategy getStrategy(String key) { return map.get(key); } } 客户端：调用上下文角色 IPayStrategy aliPay = PayFactory.getStrategy(\"ali\"); aliPay.pay(); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-08-11 19:20:34 "},"designpatterns/behavioral/delegate.html":{"url":"designpatterns/behavioral/delegate.html","title":"委派","keywords":"","body":"概念 负责任务的调用或分配，是一种特殊的静态代理，不属于23种设计模式，经典的使用有双亲委派、Spring的DispatcherServlet 组成 抽象任务角色（Task）：定义任务 public interface IEmployee { void doSomething(); } 具体任务角色（Concrete）：实现具体任务并执行 public class Programmer implements IEmployee { @Override public void doSomething(String task) { System.out.println(\"我擅长编程，我开始做\" + task); } } public class ProjectManager implements IEmployee { @Override public void doSomething(String task) { System.out.println(\"我擅长产品，我开始做\" + task); } } 委派者角色（Delegate）：实现抽象任务角色定义的接口，持有具体角色的引用，在其中决定调用哪个具体任务角色 public class Leader implements IEmployee { private static Map subordinates = new HashMap<>(); static { subordinates.put(\"软件开发\", new Programmer()); subordinates.put(\"原型设计\", new ProjectManager()); } @Override public void doSomething(String task) { IEmployee subordinate = subordinates.get(task); if (subordinate != null) { subordinate.doSomething(task); } } } 实际调用者只持有委派者的引用，给委派者分配任务，委派者再将任务分配下去 String task = \"原型设计\"; new Leader().doSomething(task); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-08-13 20:14:11 "},"designpatterns/behavioral/templatemethod.html":{"url":"designpatterns/behavioral/templatemethod.html","title":"模板方法","keywords":"","body":"模板方法 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:52 "},"designpatterns/behavioral/observer.html":{"url":"designpatterns/behavioral/observer.html","title":"观察者","keywords":"","body":"观察者 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:50 "},"designpatterns/behavioral/responsibilitychain.html":{"url":"designpatterns/behavioral/responsibilitychain.html","title":"责任链","keywords":"","body":"责任链 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:37:57 "},"designpatterns/behavioral/command.html":{"url":"designpatterns/behavioral/command.html","title":"命令","keywords":"","body":"命令 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:28:19 "},"designpatterns/behavioral/state.html":{"url":"designpatterns/behavioral/state.html","title":"状态","keywords":"","body":"状态 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:29:11 "},"designpatterns/behavioral/visitor.html":{"url":"designpatterns/behavioral/visitor.html","title":"访问者","keywords":"","body":"访问者 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:30:00 "},"designpatterns/behavioral/memento.html":{"url":"designpatterns/behavioral/memento.html","title":"备忘录","keywords":"","body":"备忘录 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:37:41 "},"designpatterns/behavioral/mediator.html":{"url":"designpatterns/behavioral/mediator.html","title":"中介者","keywords":"","body":"中介者 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:29:34 "},"designpatterns/behavioral/iterator.html":{"url":"designpatterns/behavioral/iterator.html","title":"迭代器","keywords":"","body":"迭代器 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:31:30 "},"designpatterns/behavioral/interpreter.html":{"url":"designpatterns/behavioral/interpreter.html","title":"解释器","keywords":"","body":"解释器 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:30:25 "},"concurrency/threadstate.html":{"url":"concurrency/threadstate.html","title":"线程状态与停止复位","keywords":"","body":"Java的6种线程状态 NEW 线程被构建，但是还没有调用start方法 RUNNABLE JAVA线程把操作系统中的ready和running两种状态统一称为“运行” BLOCKED 运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm 会把当前的线程放入到锁池中 WAITING 等待其他线程的通知或中断 TIMED_WAITING 超时以后自动返回 TERMINATED 运行结束或死亡 操作系统的5种线程状态 new 新建，已占用内存空间和其他系统资源，但还没有开始执行 ready 开始执行，等待系统调度分配CPU使用权 running 线程获得了CPU使用权，正在执行 waiting 等待/挂起，让出CPU资源给其他线程使用 terminated 运行结束或死亡 线程的终止与复位 终止 线程的终止，并不是简单的通过调用stop方法。虽然API仍然可以调用，但是和其他的线程控制方法如suspend、resume一样都是Deprecated的不建议使用，stop方法在结束一个线程时并不会保证线程的资源正常释放，因此会导致程序可能出现一些不确定的状态。要优雅的去中断一个线程，在线程中提供了一个interrupt方法。当其他线程通过调用当前线程的interrupt方法，表示向当前线程打个招呼，告诉它可以中断线程的执行了，至于什么时候中断，取决于当前线程自己，interrupt本质上是通过unpark方法去随机唤醒一个其他线程并将当前线程的中断标识位设为true。当前线程通过检查自身是否被中断来进行响应，可以通过isInterrupted方法来判断是否被中断。 Thread thread = new Thread(() -> { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"execute\"); } }, \"interruptDemo\"); thread.start(); TimeUnit.SECONDS.sleep(1); thread.interrupt(); 复位 线程中还提供了静态方法Thread.interrupted()对设置中断标识的线程复位。除此以外如sleep/wait/join等方法都会抛出InterruptedException异常，在InterruptedException抛出之前，JVM会先把线程的中断标识位清除，然后才会抛出InterruptedException，这个时候如果调用isInterrupted方法，也会返回 false。 Thread thread = new Thread(() -> { while (!Thread.currentThread().isInterrupted()) { try { System.out.println(\"execute\"); Thread.sleep(1000); } catch (InterruptedException e) { // 主线程调用当前线程的interrupt()会导致抛出该异常，中断标识位被置为了false，此时循环将继续 // 若想结束循环，再次中断 Thread.currentThread().interrupt(); } } }, \"interruptedDemo\"); thread.start(); thread.interrupt(); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-08-30 19:17:32 "},"concurrency/threadSecurity.html":{"url":"concurrency/threadSecurity.html","title":"线程安全之原子性、可见性、有序性","keywords":"","body":"线程安全三大问题 原子性、可见性、有序性，下面会从几个方面来分析这三个问题的原因及解决方案。 CPU缓存 高速缓存 线程是CPU调度的最小单元，线程设计的目的最终仍然是更充分的利用计算机处理的效能，但是绝大部分的运算任务不能只依靠处理器就能完成，处理器还需要与内存交互，比如读取运算数据、存储运算结果，这个IO操作是很难消除的。而由于计算机的内存与处理器的运算速度差距非常大，所以现代计算机系统都会增加一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存和处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中。 从上到下依次为L3 cache、L2 cache、L1 cache，越接近CPU速度越快，同时容量也越小。 L1 Cache 一级缓存，本地core的缓存，分成32K的数据缓存L1 d-cache和32k的指令缓存L1 i-cache，访问L1需要3cycles，耗时大约1ns； L2 Cache 二级缓存，本地core的缓存，被设计为L1缓存与共享的L3缓存之间的缓冲，大小为256K，访问L2需要12cycles，耗时大约3ns； L3 Cache 三级缓存，在同插槽的所有core共享L3缓存，分为多个2M的段，访问L3需要38cycles，耗时大约12ns； 缓存一致性问题 比如有一个变量count，CPU-0读取主内存的数据，缓存到CPU-0的高速缓存中，CPU-1也做了同样的事情，同时CPU-1把count的值修改成了2，并且同步到CPU-1的高速缓存，但是这个修改之后的值并没有写入到主内存中，CPU-0访问该变量，由于缓存没有更新，所以仍然是之前的值，就会导致数据不一致的问题。引发这个问题的原因是因为多核心CPU情况下存在指令并行执行，而各个CPU核心之间的数据不共享从而导致缓存一致性问题，为了解决这个问题，CPU生产厂商提供了相应的解决方案。 总线锁 当一个处理器对其缓存中的数据进行操作的时候，往总线中发送一个Lock#信号，其他处理器对共享内存的请求将会被阻塞。其实在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁把处理器和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以这种方式会导致CPU的性能下降，P6系列以后的处理器，出现了另外一种方式，就是缓存锁。 缓存锁 内存区域如果被缓存在处理器的缓存行中并且在LOCK操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声明LOCK#信号，而是修改内部的内存地址，然后通过缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域的数据，当其他处理器回写已经被锁定的缓存行的数据时会导致当前处理器缓存行无效。每个处理器通过嗅探其他处理器访问内存和缓存来检查自己缓存的值是否已过期，当发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态。 总线锁和缓存锁怎么选择，取决于很多因素，比如CPU是否支持、以及存在无法缓存的数据时 (比较大或者跨越多个缓存行的数据)，必然还是会使用总线锁。 缓存一致性协议 处理器上有一套完整的协议，来保证缓存的一致性，比较经典的应该就是MESI协议了，它的方法是在CPU缓存中保存一个标记位，这个标记位有四种状态： M(Modified) 修改缓存，当前CPU缓存已经被修改，表示已经和内存中的数据不一致了。 E(Exclusive) 独占缓存，当前CPU的缓存和内存中数据一致，而且其他处理器没有缓存该数据。 S(Shared) 共享缓存，当前CPU的缓存和内存中数据一致，并且该数据存在于多个CPU的缓存中，每个处理器的缓存控制器不仅知道自己的读写操作，也监听其它处理器对缓存的读写操作。 I(Invalid) 失效缓存，说明CPU的缓存已经不能使用了，得去内存重新读取。 指令重排序 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型： 编译器优化的重排序 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行重排序 现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序 处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序（2和3都属于处理器重排序）： 指令重排的目的是为了最大化的提高CPU利用率以及性能，CPU的乱序执行优化在单核时代并不影响正确性，但是在多核时代的多线程能够在不同的核心上实现真正的并行，一旦线程之间共享数据，就可能会出现一些不可预料的问题。指令重排序必须要遵循的原则是：不影响代码执行的最终结果，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序(这里所说的数据依赖性仅仅是针对单个处理器中执行的指令和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑) ，这个语义，实际上就是as-if-serial语义，不管怎么重排序，单线程程序的执行结果不会改变，编译器、处理器都必须遵守as-if-serial语义。 如果不考虑编译器重排序和缓存可见性问题，上面这段代码可能会出现的结果是 x=0,y=1; x=1,y=0; x=1,y=1这三种结果，因为可能是先后执行t1/t2，也可能是反过来，还可能是t1/t2交替执行，但是这段代码的执行结果也有可能是x=0,y=0。这就是在乱序执行的情况下会导致的一种结果，因为线程t1内部的两行代码之间不存在数据依赖，因此可以把x=b乱序到a=1之前；同时线程t2中的y=a也可以早于t1中的a=1执行，那么他们的执行顺序可能是 t1: x=b t2: b=1 t2: y=a t1: a=1 所以从上面的例子来看，重排序会导致可见性问题。但是重排序带来的问题的严重性远远大于可见性，因为并不是所有指令都是简单的读或写，比如DCL的部分初始化问题。所以单纯的解决可见性问题还不够，还需要解决处理器重排序问题。 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为 Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。 内存屏障 现在的CPU架构都提供了内存屏障功能：store barrier、load barrier、full barrier，主要的作用是: 防止指令之间的重排序 保证数据的可见性 在JMM中把内存屏障指令分为4类，通过在不同的语义下使用不同的内存屏障来禁止特定类型的处理器重排序，从而来保证内存的可见性： LoadLoad Barriers 示例：load1 ; LoadLoad; load2 , 确保load1数据的装载先于load2及所有后续装载指令的装载 StoreStore Barriers 示例：store1; storestore;store2 , 确保store1数据对其他处理器可见（即刷新到内存）先于store2及所有后续存储指令的存储 LoadStore Barries 示例：load1;loadstore;store2, 确保load1数据装载先于store2以及后续的存储指令刷新到内存 StoreLoad Barries 示例：store1; storeload;load2, 确保store1数据对其他处理器变得可见（即刷新到内存）先于load2及所有后续装载指令的装载；这条内存屏障指令是一个全能型的屏障，会使该屏障之前的所有内存访问指令（不管是存储还是装载）完成之后，才执行该屏障之后的内存访问指令（不管是存储还是装载），也就是说它同时具有其他3条屏障的效果 总结：内存屏障只是解决顺序一致性问题，不解决缓存一致性问题，缓存一致性是由cpu的缓存锁以及MESI协议来完成的。而缓存一致性协议只关心缓存一致性，不关心顺序一致性。所以这是两个问题。 JMM 其实原子性、可见性、有序性问题，是我们抽象出来的概念，它们的核心本质就是刚刚提到的缓存一致性问题、处理器优化问题导致的指令重排序问题。 比如缓存一致性就导致可见性问题、处理器的乱序执行会导致原子性问题、指令重排会导致有序性问题。为了解决这些问题，所以在JVM中引入了JMM的概念。 JMM定义了共享内存系统中多线程程序读写操作行为的规范，来屏蔽各种硬件和操作系统的内存访问差异，来实现Java程序在各个平台下都能达到一致的内存访问效果。Java内存模型的主要目标是定义程序中各个变量的访问规则，也就是在JVM中将变量存储到内存以及从内存中取出变量（这里的变量，指的是共享变量，也就是实例对象、静态字段、数组对象等存储在堆内存中的变量。而对于局部变量、方法定义的参数（方法的传参）、异常处理器的参数（catch的异常）这类的，属于线程私有，不会被共享，即不会有可见性问题）这类的底层细节。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的可见性、原子性和有序性。 JMM决定一个线程对共享变量的写入何时对另一个线程可见，它定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程用来读写共享变量的副本。本地内存是JMM的抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，不能直接读写主内存中的变量。并且不同的线程之间无法访问对方工作内存中的变量，线程间的变量值的传递都需要通过主内存来完成，它们三者的交互关系如下 JMM解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。但是JMM并没有主动限制处理器优化和指令重排序，也就是说在JMM这个模型之上，仍然会存在缓存一致性问题和指令重排序问题。JMM是一个抽象模型，它是建立在不同的操作系统和硬件层面之上 对问题进行了统一的抽象，然后在Java层面提供了一些高级指令如volatile、final等，让用户选择在合适的时候去引入这些高级指令来解决并发问题。 如何解决原子性、可见性、有序性的问题 原子性 在java中提供了两个高级的字节码指令monitorenter和monitorexit，在Java中对应的则是Synchronized来保证代码块内的操作是原子的。monitorenter和monitorexit隐式的执行了Lock和UnLock操作，Lock后其他线程无法获得锁，即使在执行过程中CPU时间片用完，线程也并没有进行解锁，而由于synchronized的锁是可重入的，下一个时间片还是只能被它自己获取到，还是会继续执行代码，直到所有代码执行完，这就保证了原子性。 可见性 Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次使用之前，JMM会把要使用该变量的线程的本地内存置为无效，线程接下来从主内存中读取。因此，可以使用volatile来保证多线程操作时变量的可见性。 除了volatile，Java中的synchronized也可以实现可见性，线程A释放锁时，JMM会把A对应的本地内存的共享变量刷新到主内存中，而当线程B在申请同一个锁时，线程B的工作内存会被设置为无效，然后线程B会重新从主内存中加载它要访问的变量到它的工作内存中。 final关键字也可以实现可见性。 有序性 在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：volatile关键字会禁止指令重排，synchronized关键字保证同一时刻只允许一个线程操作，本质上就是as-if-serial语义保证了有序性。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-08 14:50:14 "},"concurrency/volatile.html":{"url":"concurrency/volatile.html","title":"volatile原理","keywords":"","body":"volatile如何保证可见性 volatile变量修饰的共享变量，在进行写操作的时候会多出一个lock前缀的汇编指令，这个指令在前面我们讲解 CPU 高速缓存的时候提到过，会触发总线锁或者缓存锁，通过缓存一致性协议来解决可见性问题。 对于声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，把这个变量所在的缓存行的数据写回到系统内存，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否已过期，当发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态。 如下JMM针对编译器制定的volatile重排序规则表： 举例来说，第三行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。 我们可以看出： · 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile写之前的操作不会被编译器重排序到volatile写之后。 · 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile读之后的操作不会被编译器重排序到volatile读之前。 · 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。 为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略： 在每个volatile写操作的前面插入一个StoreStore屏障。 · 在每个volatile写操作的后面插入一个StoreLoad屏障。 · 在每个volatile读操作的后面插入一个LoadLoad屏障。 · 在每个volatile读操作的后面插入一个LoadStore屏障。 上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。 下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图： 图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。 这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。 为了保证能正确实现volatile的内存语义，JMM有两种策略： 1、在每个volatile写的后面插入一个StoreLoad屏障， 2、在每个volatile 读的前面插入一个StoreLoad屏障。 从整体执行效率的角度考虑，JMM最终选择了在每个 volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个 写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时， 选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。 上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。 LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。 在实际执行时，只要不改变 volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。 最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器通常会在这里插入一个StoreLoad屏障。 上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模 型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。如果硬件架构本身已经保证了内存可见性，那么volatile就是一个空标记，不会插入相关语义的内存屏障。如果硬件架构本身不进行处理器重排序，有更强的重排序语义，那么volatile就是一个空标记，不会插入相关语义的内存屏障。 volatile如何保证有序性 volatile为什么不能保证原子性 对任意单个volatile变量的读写具有原子性，但类似于volatile++这种复合操作不具有原子性 然后通过javap -c Demo.class，去查看字节码 对一个原子递增的操作，会分为三个步骤： 1.读取volatile变量的值； 2.增加变量的值； 3.回写变量的值。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-01 11:42:43 "},"concurrency/synchronized.html":{"url":"concurrency/synchronized.html","title":"synchronized详解","keywords":"","body":"synchronized的三种应用方式 修饰普通方法，锁是当前实例对象 修饰静态方法 锁是当前类的Class对象 修饰方法体中的代码块（不能修饰类里面的构造代码块或静态代码块），锁是synchronized后面括号里指定的对象 synchronized的字节码指令 通过javap -v来查看对应代码的字节码指令， 对于同步方法，JVM采用ACC_SYNCHRONIZED标记符来实现同步，同步方法的常量池中会有一个ACC_SYNCHRONIZED标志，当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED标志，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁，这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。 对于同步代码块则使用了monitorenter和monitorexit指令，monitorenter指令插入到同步代码块开始的位置，monitorexit指令插入到同步代码块结束位置和异常处，编译器需要确保方法中调用过的每条monitorenter指令都要执行对应的monitorexit指令。为了保证在方法异常时，monitorenter和monitorexit指令也能正常配对执行，编译器会自动产生一个异常处理器，它的目的就是用来执行异常的monitorexit指令。所以会有两个monitorexit指令，多的那个就是异常结束时，被执行用来释放monitor的。 同步方法是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。任何对象都有且仅有一个监视器（monitor）与之关联，无论采用三种方式中的哪种，其本质是对一个对象的监视器进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到锁对应对象的监视器。 任意线程对Object（锁对象）的访问，线程执行到monitorenter指令时，首先要获得Object的监视器（获取锁）。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当持有monitor（获得了锁）的线程执行monitorexit，释放monitor的所有权（释放锁），则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。 synchronized的锁的原理 对象 在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。 对象头 包括Mark Word、Klass Pointer和数组长度（如果对象是数组的话）三个部分，Klass Pointer是Class对象的类型指针，Jdk1.8默认开启指针压缩后为4字节，关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节。其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址。 对象实际数据 包括对象的所有成员变量，大小由各个成员变量决定，比如：byte占1个字节8比特位、int占4个字节32比特位。 对齐 最后这段空间补全并非必须，仅仅为了起到占位符的作用。由于HotSpot虚拟机的内存管理系统要求对象起始地址必须是8字节的整数倍，所以对象头正好是8字节的倍数。因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 对象头 如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。 32位JVM的Mark Word的默认存储结构如下： 在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化，Mark Word可能变化为存储以下数据： 在64位JVM下，Mark Word是64bit大小的，其存储结构下： 如下，每一行是一个状态，每个状态下Mark Word存储内容不一样，无其他线程竞争的情况下，由normal object变为biased object。 锁升级 自旋锁 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁。 自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。 适应性自旋锁 自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。 偏向锁 在大多数情况下，锁不仅仅不存在多线程的竞争，而且总是由同一个线程多次获得，在这个背景下就设计了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 轻量级锁 如果偏向锁被关闭（一般实际都是关闭的）或者当前偏向锁已经被其他线程获取，那么这个时候如果有线程通过自旋去抢占同步锁时，锁会升级到轻量级锁。 加锁 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针,并将锁记录里的owner指针指向对象的Mark Word。如果成功，当前线程获得锁，如果失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 解锁 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。 重量级锁 重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。 锁对比 偏向锁、轻量级锁都是乐观锁，不会阻塞，重量级锁是悲观锁，会阻塞。 锁消除 锁消除即删除不必要的加锁操作。虚拟机即时编辑器在运行时，对一些“代码上要求同步，但是被检测到不可能存在共享数据竞争”的锁进行消除。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。 public class SynchronizedTest { public static void main(String[] args) { SynchronizedTest test = new SynchronizedTest(); for (int i = 0; i 虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去（即sb的引用没有传递到该方法外，不可能被其他线程拿到该引用），所以其实这过程是线程安全的，可以将锁消除。 锁粗化 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。 public class StringBufferTest { StringBuffer stringBuffer = new StringBuffer(); public void append(){ stringBuffer.append(\"a\"); stringBuffer.append(\"b\"); stringBuffer.append(\"c\"); } } 这里每次调用stringBuffer.append()都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append时进行加锁，最后一次append结束后进行解锁。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-05 18:06:50 "},"concurrency/wait&notify.html":{"url":"concurrency/wait&notify.html","title":"wait与notify原理","keywords":"","body":"原理 wait方法 调用的前提是持有监视器锁，若持有锁，会让当前线程变成等待状态，进入等待队列并且释放锁。 notify/notifyAll方法 如果是notify，会选择从等待队列中唤醒任意一个线程，但是并不会立马唤醒线程，因为当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁，必须要等当前的线程执行完monitorexit指令即锁被释放以后，此时处于等待队列中的线程就可以开始竞争锁了。 wait和notify为什么需要在synchronized里面 wait的语义有两个，一个是释放当前的对象锁，另一个是使得当前线程进入阻塞队列，而这些操作都和监视器相关，所以wait必须要获得一个监视器锁。 notify也是一样，它是唤醒一个线程，首先得知道它在哪里，所以就必须要找到这个对象，获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-01-27 18:10:04 "},"concurrency/cas&atomic.html":{"url":"concurrency/cas&atomic.html","title":"CAS的ABA问题及原子类","keywords":"","body":"CAS的ABA问题 问题 CAS是检查值没有发生变化则更新，但是如果一个值A变成了B，然后再变成A，刚好在做CAS时检查发现值并没有变化依然为A，但是实际上却发生了变化。 解决方案 添加一个版本号，原来的变化路径A->B->A就变成了1A->2B->3A。 atomic包中的AtomicStampedReference即是这样，首先检查当前引用是否等于预期引用，接着检查当前标识是否等于预期标识，都相等的情况下才会更新。 public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair current = pair; return expectedReference == current.reference && expectedStamp == current.stamp && ((newReference == current.reference && newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000 Atomic原子类 基本类型对应：AtomicBoolean、AtomicInteger、AtomicLong 数组类型对应：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray 引用类型对应：AtomicReference、AtomicReferenceFieldUpdater、AtomicMarkableReference（除引用类型还带有一个boolean类型的标记位） 对象的属性类型对应：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicStampedReference Atomic包里的类基本都是使用Unsafe的如下三个方法之一实现CAS的 public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5); public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); 那么AtomicBoolean怎么实现呢？可以看到是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新char、float和double变量也可以用类似的思路来实现。 public final boolean compareAndSet(boolean expect, boolean update) { int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u); } Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-01-28 15:47:03 "},"concurrency/threadLocal.html":{"url":"concurrency/threadLocal.html","title":"ThreadLocal源码分析","keywords":"","body":"Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-08 15:43:25 "},"distributed/BIO、NIO、AIO.html":{"url":"distributed/BIO、NIO、AIO.html","title":"BIO、NIO与AIO","keywords":"","body":"BIO 同步阻塞IO，面向流，从流中读取数据，向流中写入数据。 线程调用accept()、read()、write()时，该线程被阻塞，直到有客户端连接、数据读取完成、数据写入完成为止，线程在此期间不能干其他事情。 // 服务端是ServerSocket ServerSocket server = new ServerSocket(8080); while (true) { //等待客户端连接，accept是阻塞的 Socket client = server.accept(); // 获取流 InputStream is = client.getInputStream(); // 通过流读取数据 byte [] buff = new byte[1024]; int len = is.read(buff); if(len > 0){ String msg = new String(buff, 0 ,len); } } // 客户端是Socket，localhost:8080是服务端地址 Socket client = new Socket(\"localhost\", 8080); // 获取流 OutputStream os = client.getOutputStream(); // 通过流写入数据 os.write(\"hello\".getBytes()); NIO 同时支持同步阻塞IO与同步非阻塞IO，通过configureBlocking(true/false)控制，面向缓冲区（buffer），数据从通道（channel）读取到buffer中，写入也是到buffer中。 线程请求从channel读取数据到buffer，如果目前没有数据，线程可以去做别的事情，当有数据读取到buffer中后，线程再继续处理数据。写数据也是一样的，线程请求写入数据到channel，但不需要等待它完全写入，线程可以去做别的事情，比如可以在其他channel上执行IO操作，所以一个线程可以管理多个channel。 ServerSocketChannel serverChannel = ServerSocketChannel.open(); serverChannel.bind(new InetSocketAddress(8080)); // NIO模型默认是阻塞式，在此开启非阻塞模式 serverChannel.configureBlocking(false); Selector selector = Selector.open(); // OP_ACCEPT表示有客户端发起TCP连接 serverChannel.register(selector, SelectionKey.OP_ACCEPT); // 不断地循环，就叫轮询 while (true) { // select方法阻塞的等待有IO的信道，直到有信道了返回或者等待超时返回 selector.select(); Set keys = selector.selectedKeys(); Iterator iter = keys.iterator(); //同步体现在这里，因为每次只能拿一个key，每次只能处理一种状态 while (iter.hasNext()){ SelectionKey key = iter.next(); if (key.isAcceptable()) { // 非阻塞模式下，accept方法不是阻塞的，如果没有信道，就返回null SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept(); clientChannel.configureBlocking(false); //当数据准备就绪的时候，将状态改为可读 clientChannel.register(selector, SelectionKey.OP_READ); } else if (key.isReadable()) { //key.channel 从多路复用器中拿到客户端的引用 SocketChannel clientChannel = (SocketChannel)key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); int len = clientChannel.read(buffer); // 非阻塞模式下，read方法可能没读取到数据时就返回了，所以得判断下 if(len > 0){ buffer.flip(); String content = new String(buffer.array(), 0, len); key = channel.register(selector, SelectionKey.OP_WRITE); //在key上携带一个附件，一会再写出去 key.attach(content); } } else if (key.isWritable()) { SocketChannel channel = (SocketChannel)key.channel(); String content = (String)key.attachment(); channel.write(ByteBuffer.wrap((content).getBytes())); channel.close(); } // Selector不会自己从已选择键集中移除SelectionKey实例,必须在处理完通道时自己移除 iter.remove(); } } AIO 异步非阻塞IO Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-22 17:30:42 "},"jvm/classload.html":{"url":"jvm/classload.html","title":"类加载","keywords":"","body":"类加载的流程 装载 通过类的全限定名获取它的二进制字节流（字节码增强就是在这一阶段做） 将二进制字节流代表的静态存储结构转化为方法区的运行时数据结构 在堆中生成该类对应的Class对象，作为方法区数据的访问入口 验证 验证Class对象中的字节流符合jvm要求，不会对jvm安全产生危害，可通过-Xverify:none关闭验证。 准备 为类变量（静态变量）在方法区中分配内存并设置默认初始值，int、long、short、char、byte、boolean、float、double、reference默认值分别为0、0L、（short）0、'\\u0000'、（byte）0、false、0.0f、0.0d、null。这里的类变量不包含用final修饰的static变量，因为这样的变量称为ConstantValue属性（仅限基本类型和String），在编译时就已分配好，在准备阶段会设置代码中给它指定的值，而非基本类型和String的以及没有final修饰的static的则在类构造器中被设置代码指定的值，其他的则在实例构造器中被赋值。比如 private static final int a = 2; private static final int b = 2; 在准备阶段，a就被赋值为了2，而b只是赋值为默认的0，b得等到初始化阶段才会被赋值为2。 解析 将类常量池中的符号引用转化为直接引用。 初始化 调用类构造器，只有主动引用会触发该阶段，被动引用不会触发该阶段。 主动引用 new创建实例 访问非final的静态变量或者对非final的静态变量赋值 调用静态方法 反射，如Class.foeName(\"com...mysql.Driver\") 初始化子类，则父类也会被初始化 jvm启动时被标为启动类的类，如xxApplication 被动引用 引用父类的静态字段，只会引起父类的初始化，不会引起子类的初始化 定义类数组，不会引起初始化 引用类的static final变量，不会引起初始化 类加载器 类加载器共有4种类型，一个类在同一个类加载器中具有唯一性，但不同类加载器中是可以有同名类的，这样的类无法通过instanceof、equals的校验。 BootstrapClassLoader 又称根加载器，加载java.. 这些类 ExtensionClassLoader 加载javax.. 这些类 AppClassLoader 又称系统类加载器，加载开发写的代码和第三方jar包里类，可以通过ClassLoader.getSystemClassLoader()获取 双亲委派 检查类是否已加载，如果没有则委托父类加载器加载，父类加载器再检查类是否已加载，如果没有则委托父类的父类加载器加载，这样一直往上，如果最顶层的加载器在类路径范围内找不到该类时，就把类加载的任务扔回给子类加载器，这样一直往下，最终可能又回到最开始的类加载器。比如AppClassLoader先委托ExtensionClassLoader，ExtensionClassLoader又委托BootstrapClassLoader，BootstrapClassLoader一找没找到，就会打回给ExtensionClassLoader，ExtensionClassLoader再一找，没找到，又会打回给AppClassLoader，AppClassLoader找到了就返回对应的Class，没找到就抛异常，不会往下找子类加载器去加载。 protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 打破双亲委派 SPI JDK在核心类库rt.jar中定义接口及调用逻辑，开发者在META-INF/serices目录下提供实现。 自定义类加载器并重写loadClass方法，比如tomcat 自定义类加载器 主要是继承ClassLoader，并重写findClass方法，在findClass方法里调用defineCass方法，findClass方法不会破坏双亲委派 要加载的类不能放在类路径下，否则根据双亲委派，该类会先被AppClassLoader加载 延迟加载 JVM并不是一次性加载所有类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会通过ClassLoader来加载这些类。加载完成后就会将Class对象存在ClassLoader里面，下次就不需要重新加载了。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-26 18:14:31 "},"jvm/memory.html":{"url":"jvm/memory.html","title":"内存","keywords":"","body":"常量池 静态常量池 存储字面量及符号引用 运行时常量池 字符串常量池 内存模型 方法区 线程共享，JVM启动时创建，又名非堆，存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，JDK1.8后方法去被分为两部分，类信息存储在元空间，运行时常量池存储在堆中 堆 线程共享，JVM启动时创建，存储对象实例及数组，空间不足时会OOM，分为Old区和Young区，Young区又分为Survivor区(S0和S1，一样大，又称from区和to区)和Eden区 JVM默认为每个线程在Eden上开辟一个buffer区域，用来加速对象的分配，称之为TLAB，全称:Thread Local Allocation Buffer。 对象优先会在TLAB上分配，但是TLAB空间通常会比较小（默认是Eden区的百分之1），如果对象比较大，那么还是在共享区域分配。 Survivor区存在的意义 如果没有，Eden区每进行一次Minor GC，存活的对象就会被送到老年代，老年代很快被填满，触发Major GC(因为Major GC一般伴随着Minor GC,也可以看做触发了Full GC)，耗时较长。所以Survivor区的存在意义就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor区规定只有经历16次Minor GC还能在新生代中存活的对象才会被送到老年代。 两个Survivor区的必要性 解决空间碎片。 虚拟机栈 线程私有，线程创建时创建，存储线程的运行状态，每一个被线程执行的方法对应栈中的一个栈帧，调用方法压栈，调用完成弹栈。 每个栈帧中包含局部变量表（方法中定义的局部变量以及方法的参数存放在这张表中，局部变量表中的变量不可直接使用，如需要使用的话，必须通过相关指令将其加载至操作数栈中作为操作数使用）、操作数栈、动态链接（指向运行时常量池的引用）、方法返回地址和附加信息。 程序计数器 线程私有，记录线程执行到的位置，以便重新获取到CPU时间片开始执行时能继续执行。 如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是Native方法，则这个计数器为空。 本地方法栈 线程私有，如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-28 18:32:49 "},"jvm/reference.html":{"url":"jvm/reference.html","title":"强引用、软引用、弱引用与虚引用","keywords":"","body":"强引用 如下，把一个对象赋给一个引用变量a，这个对象处于可达状态，永远不会被垃圾回收，JVM宁愿抛出OOM，因此强引用是造成内存泄漏的主要原因之一。 Object a = new Object()； a = null; // 释放强引用 软引用 用SoftReference类来实现，可以引用队列联合使用，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用来实现缓存。 Object a = new Object()； SoftReference sr = new SoftReference(a); a = null; // 释放强引用 // 先判断软引用是否已被回收 if (wr != null) { Object obj = sr.get(); // 获取软引用里的对象 } 弱引用 用WeakReference类来实现，可以引用队列联合使用，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。 Object a = new Object()； WeakReference wr = new WeakReference(a); a = null; // 释放强引用 // 先判断弱引用是否已被回收 if (wr != null) { Object obj = wr.get(); // 获取弱引用里的对象 } 虚引用 用PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。主要作用是跟踪对象被垃圾回收的状态。 Object a = new Object()； ReferenceQueue queue = new ReferenceQueue(); PhantomReference pr = new PhantomReference(a, queue); a = null; // 释放强引用 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-26 17:13:03 "},"jvm/lifecycle.html":{"url":"jvm/lifecycle.html","title":"类的生命周期","keywords":"","body":" 创建 为对象分配存储空间，开始构造对象，从超类到子类对static成员进行初始化，超类成员变量按顺序初始化，递归调用超类的构造方法，子类成员变量按顺序初始化，子类构造方法调用。一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段 应用 对象至少被一个强引用引用着 不可见 程序本身不再持有对象的强引用，虽然引用还存在着（如某些已装载的静态变量或线程或JNI,即GC root），换句话说，程序的执行已经超出了对象的作用域 不可达 对象不再被任何强引用引用着 收集 当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了 finalize方法，则会去执行该方法的终端操作。但是最好不要去重写finalize方法，原因有二： 会影响JVM的对象分配与回收速度 在分配该对象时，JVM需要在垃圾回收器上注册该对象，以便在回收时能够执行该重载方法;在该方法执行时需要消耗CPU时间且在执行完该方法后才会重新执行回收操作，即至少需要垃圾回收器对该对象执行两次GC。 可能造成该对象的再次“复活” 在finalize方法中，如果有其它的强引用再次持有该对象，则会导致对象的状态由“收集阶段”又重新变为“应用阶段”。这个已经破坏了Java对象的生命周期进程，且“复活”的对象不利于后续的代码管理。 终结 当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段，在该阶段是等待垃圾回收器对该对象进行回收。 空间重分配 垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-26 19:25:03 "},"jvm/gcAlgorithm.html":{"url":"jvm/gcAlgorithm.html","title":"垃圾回收算法","keywords":"","body":"标记-清除（Mark-Sweep） 标记 扫描堆中的所有对象，找出需要回收的，标记出来，比较耗时。 清除 清除掉标记需要回收的对象，比较耗时 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收。 标记-复制（Mark-Copy） 将内存划分为两块相等的区域，每次只使用其中一块，当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间清空，这样空间利用率会降低。 标记-整理（Mark-Compact） 标记 与标记-清除算法的标记一致 整理 让所有存活的对象都向一端移动，清理掉边界以外的内存。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-26 19:04:58 "},"jvm/gcr.html":{"url":"jvm/gcr.html","title":"垃圾收集器","keywords":"","body":"垃圾收集器 并发和并行 并发 GC线程和用户线程同时进行，比如CMS，G1 并行 多线程进行GC，比如ParNew，Parallel Scavenge Serial 一种新生代单线程收集器，使用的标记-复制算法，在垃圾收集的时候会暂停其他线程。 Serial Old 一种老年代单线程收集器，使用的标记-整理算法，在垃圾收集的时候会暂停其他线程。 ParNew Serial收集器的多线程版本，一种新生代多线程收集器，使用的标记-复制算法，在垃圾收集的时候会暂停其他线程，且单CPU时比Serial效率差。 Parallel Scavenge 一种新生代多线程收集器，使用的标记-复制算法，在垃圾收集的时候会暂停其他线程，相较于ParNew更注重系统吞吐量。这里的吞吐量是指运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)，显然垃圾收集的时间越短，吞吐量越大，可以通过-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间或者-XX:GCTimeRatio直接设置 吞吐量大小。 Parallel Old Parallel Scavenge收集器的老年代版本，一种老年代多线程收集器，使用的标记-整理算法，在垃圾收集的时候会暂停其他线程，相较于Serial Old更注重系统吞吐量。 CMS 一种以获取最短回收停顿时间为目标的收集器，使用的标记-清除算法，共有四步，其中并发标记和并发清除两步，GC线程与用户线程是可以同时进行的，所以CMS是一个并发类收集器。注意，CMS并发GC不是Full GC。 初始标记 只标记GC roots直接关联对象，不顺着链再往下标记，速度快 并发标记 顺着链再往下标记 并发预清理 帮重新标记阶段先做点工作，扫描一下卡表脏的区域和新生代晋升到老年代的对象等 重新标记 修改并发标记后因程序产生的变动，该阶段较为耗时 并发清除 清除对象，回收空间，产生浮动垃圾（留着下次清理） G1 一种以可预测的停顿(比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒)为优势的收集器，使用的标记-整理算法，共有四步，前三步与CMS基本一致，不同的是第四步为并发清除，会对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划 G1将整个Java堆划分为多个大小相等的独立区域(Region)，可通过-XX:G1HeapRegionSize设置Region大小，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合，所以不要设置新生代和老年代的大小，只要设置堆大小即可。每个Region大小都是一样的，可以是1M到32M之间的数值，但是必须保证是2的n次幂。如果对象太大，一个Region放不下(超过Region大小的50%)，那么就会直接放到H中 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-01 19:41:23 "},"jvm/command&args.html":{"url":"jvm/command&args.html","title":"常用命令与参数","keywords":"","body":"常用命令 jps 查看java进程 jmap jmap -heap PID 查看堆内存信息 jmap -dump:format=b,file=heap.hprof PID dump出堆内存信息 jinfo jinfo -flag name PID 查看进程的某个属性 jinfo -flags PID 查看被赋值的参数 jstat jstat -gc PID 1000 查看gc情况，每1000ms输出一次,分别表示Survivor0区的大小，Survivor1区的大小，Survivor0区已使用空间，Survivor1区已使用空间，Eden区的大小，Eden区已使用空间，老年代的大小，老年代已使用空间，元空间的大小，元空间已使用空间，压缩类的大小，压缩类已使用空间，Young GC次数，Young GC总耗时，Full GC次数，Full GC总耗时，GC总耗时，耗时的单位为秒。 jstat -class PID 1000 查看类加载情况，每1000ms输出一次 jstack PID 查看进程的堆栈信息 java -XX:+PrintFlagsFinal 查看jvm配置 参数之-XX Boolean类型 格式:-XX:[+-] +或-表示启用或者禁用 如-XX:+UseConcMarkSweepGC 表示启用CMS类型的垃圾回收器，-XX:+UseG1GC 表示启用G1类型的垃圾回收器 非Boolean类型 格式:-XX= 表示name属性的值是value 如:-XX:MaxGCPauseMillis=500 常用参数 -Xms4096M 初始堆大小,等同于-XX:InitialHeapSize=4096M -Xmx4096M 最大堆大小，等同于-XX:MaxHeapSize=4096M，为了避免jvm在gc后调整大小，一般Xms和Xmx设置同样的值 -XX:MinHeapFreeRatio=40 默认40，表示空余堆内存小于40%时，JVM就会增大堆直到-Xmx的值，一般不设置 -XX:MaxHeapFreeRatio=70 默认70，表示空余堆内存大于70%时，JVM会减少堆直到-Xms的值，一般不设置 -Xmn1024M 新生代大小 -Xss128k 每个线程的堆栈大小，一般小的应用，如果栈不是很深，128k是够用的，大的应用建议使用256k。这个选项对性能影响比较大，不要盲目设置，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就会影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。 -XX:MetaspaceSize=128M 初始元空间大小 -XX:MaxMetaspaceSize=256M 最大元空间大小 -XX:SurvivorRatio=8 新生代中Eden区与Survivor区的比值，Survivor区默认为1，比如8表示(S0+S1):Eden=2:8，即一个S区占整个新生代的1/10 -XX:NewRatio=4 老年代与新生代的比值，新生代默认为1，比如4表示新生代:老年代=1:4，也就是新生代占整个堆内存的1/5，Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置 -XX:MaxTenuringThreshold=6 对象进入老年代的年龄阈值，各个垃圾收集器不一样，Serial和ParNew GC默认是15，如果设置为0的话，则新生代对象不经过Survivor区，直接进入年老代。对于老年代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则新生代对象会在Survivor区进行多次复制，这样可以增加对象在新生代的存活时间，增加在新生代被回收的概率。 -XX:+UseParallelGC 新生代使用Parallel收集器 -XX:ParallelGCThreads=4 并行垃圾回收的线程数，一般与机器处理器数量相等，对Parallel和CMS都有效 -XX:+UseParallelOldGC 老年代使用ParallelOld收集器 -XX:+UseConcMarkSweepGC 老年代使用CMS收集器 -XX:+UseG1GC 新生代与老年代使用G1收集器 -XX:+HeapDumpOnOutOfMemoryError 堆内存溢出时，生成dump文件 -XX:HeapDumpPath=heap.hprof 堆内存溢出时，在当前目录生成一个heap.hprof文件 打印gc日志 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:gc.log -XX:+DisableExplicitGC 使System.gc()失效，System.gc()会间接导致堆外内存的回收，如果禁用，可能导致Netty等框架里无法回收堆外内存 -XX:+CMSParallelRemarkEnabled 开启并行标记,节省新生代标记时间 -XX:CMSInitiatingOccupancyFractio=70 老年代使用了指定阈值的内存时，触发Full GC，默认为-1时，以((100 - MinHeapFreeRatio) + (double)( CMSTriggerRatio * MinHeapFreeRatio) / 100.0) / 100.0 为阈值， -XX:+UseCMSInitiatingOccupancyOnly 只使用设定的回收阈值(CMSInitiatingOccupancyFractio)，如果不指定,JVM仅在第一次使用设定值，后续则自动调整 -XX+UseCMSCompactAtFullCollection CMS不会移动内存的，因此非常容易产生碎片，导致内存不够用，用它开启对年老代的内存压缩。 -XX:LargePageSizeInBytes=128m 堆的分页页面大小 -XX:UseFastAccessorMethods 原始类型get,set方法转化成本地方法，是一种优化 -XX:+UseAdaptiveSizePolicy 并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等 -XX:G1HeapWastePercent=10 默认是10%，如果G1并发标记阶段可回收的空间小于10%，则不会触发MixedGC。 -XX:MaxGCPauseMillis=200ms G1最大停顿时间，太小的话（比如50ms）就会导致出现G1跟不上垃圾产生的速度，最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。 -XX:ConcGCThreads=4 G1并发标记阶段使用的线程数量 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-01 19:46:38 "},"jvm/tunning.html":{"url":"jvm/tunning.html","title":"性能调优","keywords":"","body":"内存 内存泄漏 不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的。 内存溢出 一般两个原因： 内存泄漏 通常是代码原因。 高并发 可以通过浏览器缓存、CDN静态资源服务器、动静分离、应用缓存、限流、Tomcat优化、异步中间件、分布式锁等来缓解。 CPU top -Hp PID 查看进程中占用CPU高的线程id，即下面所需的TID jstack PID | grep TID 查看tid的堆栈信息 GC 尽量让对象在新生代就被回收，防止过多的对象晋升到老年代，减少大对象的分配 平衡垃圾回收的次数（吞吐量）和停顿时间两个指标 对象年龄晋升的阈值等参数 如何调优 dump出堆文件，用mat分析 打印gc.log，用gcviewer分析 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-01 19:34:48 "},"db/mysqltransaction.html":{"url":"db/mysqltransaction.html","title":"MySQL事务","keywords":"","body":"简介 除了做集群的NDB，只有InnoDB支持事务，MyISAM不支持 除了DML，单挑DDl（create、drop）和DCL（grant、revoke）也有事务 通过begin或者start transaction开启，通过rollback回滚或commit提交，或者客户端连接断开，事务也会回滚 事务的四大特性 原子性（Atomicity） 一系列操作要么一起成功，要么一起失败，如果前面的操作成功，后面有操作失败，在InnoDB里通过undo log（记录了数据修改之前的值）来回滚。 隔离性（Isolation） 多个事务对表或行的并发操作应该互不干扰 持久性（Durability） 事务提交后的结果不能因为宕机、重启等丢失，在InnoDB里通过redo log和双写缓冲来实现（操作数据时，会先写到内存的buffer pool里，同时记录redo log，如果刷盘之前出现异常，重启后就可以读取redo log，写入磁盘，前提是通过双写缓冲保证了数据页完整，没有被破坏）。 一致性（Consistent） 原子性、隔离性、持久性最终都是为了实现一致性，一致性的概念比较笼统，可以简单理解为从语义上讲事务执行前后数据都是合法的，比如A转账1000给B，A账户减少1000，B涨幅增加500，或者A账户余额为0，转账1000余额变成了-1000，这些都是不合法的，违反了一致性。 脏读、幻读、不可重复读 脏读 一个事务读取到了其他事务未提交的数据，而其他事务可能回滚 幻读 一个事务读取到了其他事务插入类型的已提交的数据，导致墙前后两次读取到的数据不一致 不可重复读 一个事务读取到了其他事务修改或删除类型的已提交的数据，导致前后两次读取到的数据不一致 事务的隔离级别 Read UnCommitted（未提交读） 一个事务可以读取到其他事务未提交的数据，没解决任何问题 Read Committed（已提交读） 一个事务只可以读取到其他事务已提交的数据，解决了脏读问题 Repeatable Read（可重复读） 同一个事务里面多次读取同样的数据结果是一样的，解决了不可重复读的问题，但没有解决幻读的问题（除了InNoDB，它在这个级别基于临键锁解决了幻读的问题） Serializable（串行化） 事务串行，没有并发，解决了所有问题 事务隔离的两种方案 LBCC 全称Lock Based Concurrency Control，基于锁的并发控制，另起一篇单独讲。 MVCC 基本概念 全称Multi Version Concurrency Control，主要原理是建立快照，此后只读取快照。简单来说就是只能看到本事务第一次查询之前的数据，之后数据的增删改都对本事务不可见。 原理 InnoDB为每行记录都实现了两个隐藏字段： DB_TRX_ID 事务ID，6字节，记录数据是在哪个事务插入或修改为新数据的 DB_ROLE_PTR 回滚指针，7字节，记录数据是在哪个事务被删除或记录为旧数据的，默认为NULL 每个事务都维护了一个叫Read View的数据结构，RR中Read View是事务第一次查询的时候建立的，RC中事务每次查询都会建立。 通过如下几条规则来保证只能查找DB_TRX_ID小于等于当前事务ID且DB_ROLE_PTR大于等于当前事务ID的原则： 从数据的最早版本开始判断（数据的所有版本存在undo log） 数据版本的trx_id = creator_trx_id，本事务修改，可以访问 数据版本的trx_id 数据版本的trx_id > max_trx_id，生成ReadView之后的版本，不可以访问 数据版本的trx_id在min_trx_id和max_trx_id之间，如果在m_ids中，不可以访问，不在则可以访问 如果当前版本不可见，就找undo log中的下一个版本 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-04 15:49:54 "},"db/mysqllock.html":{"url":"db/mysqllock.html","title":"MySQL锁","keywords":"","body":"简介 MyISAM只支持表锁，InnoDB支持表锁和行锁，InnoDB的行锁其实是锁的索引 锁的类型 共享锁 行级别，又称读锁，多个事务可以共享一把锁。主要用于不允许其他事务修改数据的情况，加上共享锁后不要写数据，可能会死锁。 通过select...lock in share mode来加锁，事务结束后锁自动释放。 排他锁 行级别，又称写锁，一个事务加锁后，该行的写锁和读锁都不能被其他事务获取。 通过SELECT...FOR UPDATE来加锁，增删改类型的会默认加锁。 意向共享锁 给一行数据加共享锁前，数据库会自动在表上加意向共享锁，作用为提高加表锁时的效率（加表锁前需要确保没有行锁，如果没有这个意向锁就需要全表扫描来确定有没有行锁）。 意向排他锁 给一行数据加排他锁前，数据库会自动在表上加意向排他锁，作用为提高加表锁时的效率（加表锁前需要确保没有行锁，如果没有这个意向锁就需要全表扫描来确定有没有行锁）。 自增锁 一种特殊的表锁，防止自增字段重复，数据插入后就会释放，不需要等到事务提交才释放。 行锁的算法 记录锁 对于唯一性索引（唯一索引和主键索引）使用等值查询，精准匹配到一条记录的时候，使用的记录锁。 间隙锁 查询的记录不存在，没有命中任何一个record，无论使用等值查询还是范围查询，都是使用的间隙锁，其主要目的是为了阻塞插入类型，select类型的不会被阻塞。 临键锁 使用范围查询，不仅命中了record，还包含了gap，使用的临键锁。 不同隔离级别对应的锁 RU 不加锁 RC 普通的select基于mvcc，不加锁，加锁的select使用记录锁 RR 普通的select基于mvcc，不加锁，加锁的select以及update、delete会使用记录锁、间隙锁、临键锁 Serializable 所有的select都会被转换为select...in share mode，会和update、select互斥 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-04 15:10:27 "},"db/mysqlindex.html":{"url":"db/mysqlindex.html","title":"MySQL索引","keywords":"","body":"基本概念 当用树的结构来存储索引的时候，访问一个节点就要发生一次磁盘IO，InnoDB操作磁盘的最小的单位是一页，大小是16k，所以一个节点必须设计成16k的大小，存储尽量多的数据，以减少磁盘IO的次数。由此衍生了多路平衡查找树，即B Tree。 B Tree 特点是分叉数比关键字数多1 B+ Tree 特点是分叉数和关键字数相等，只有叶子节点存储数据，且每个叶子节点的最后一个数据会指向下一个叶子节点的第一个数据，形成链表。 B+ Tree和B Tree的区别 B Tree解决的主要问题为存储更多关键字和更多个分叉以减少树的深度，B+ Tree也能做到 B+ Tree扫库扫表能力更强，全表扫描只需遍历叶子节点，而不需要遍历整棵树 B+ Tree非叶子节点不存数据，所以可以存储更多的关键字 排序更强，叶子节点上组成了链表 效率更稳定，数据都在叶子节点，查找的IO次数稳定 为什么不用红黑树 只有两路 深度差达到2倍，不够平衡 哈希索引 数据不是按顺序存储的，不能用于排序 因为要根据键值计算哈希码，所以只支持等值，不支持范围查询 字段重复值很多的时候，会出现大量的哈希冲突 InnoDB中不能显式的创建哈希索引，只有Memory引擎可以 聚簇索引 又称聚集索引，索引键值的顺序和表数据行的物理存储顺序一致，InnoDB里主键索引即聚簇索引，只有聚簇索引的叶子节点存放数据（数据地址），其他索引（称为二级索引）的叶子节点存放的是记录对应的主键，查询数据时先在二级索引树上找到对应主键，再根据对应主键去聚簇索引树上找到数据，这样的操作称为回表。 对于一张表来说： 如果有主键，聚簇索引就是主键 如果没有，聚簇索引是第一个不包含NULL值得唯一索引 如果也没有，InoDB会选择隐藏的6字节的ROWID作为聚簇索引，ROWID会随着行记录的写入而递增。 覆盖索引 如果select的数据正好索引里全有，不需要回表再查，就叫覆盖索引。 索引条件下推（ICP） 全称Index Condition Pushdown，只适用于二级索引，指把过滤数据的操作在存储引擎层完成，而不是让server去做。 索引的注意事项 在where判断、group by、order by、join on的字段上加索引 不是越多越好，占空间，数据变更导致的索引变更耗时 过长的字段建立前缀索引 随机的值不要建索引，比如身份证、UUID 联合索引把选择性好的放前面 字符串查询时要加引号，否则会出现隐式转换，不走索引 not like、函数、+-*/不走索引，!=、<>、not in有些情况不走索引 列的离散度：count(distinct(colume_name)) : count(*)，显然，列的重复值越多，离散度越低，这样的列不适合建索引 联合索引最左匹配 如果有一个a,b,c组成的联合索引，想要走该索引，where中必须要有a，可以有a有b有c，也可以有a和b，也可以只有a，但是不能只有a和c，或者b和c，或者只有a，或只有c Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-04 20:23:50 "},"db/mysqltunning.html":{"url":"db/mysqltunning.html","title":"MySQL性能优化","keywords":"","body":"SQL优化 小表驱动大表 通过explain查看一个涉及多表的关联查询的执行计划，发现id列可能不一样，也可能一样，ID不同的按大小顺序，ID相同的按从上到下顺序，所以要把查询的中间结果较少的表放在前面。 通过执行计划分析是否走了正确的索引 用join代替子查询 not exist转换成left join IS NULL OR改成UNION 结果集允许重复的情况下，用UNION ALL代替UNION 表结构设计 固定长度的用char，不要用varchar，varchar需要额外的字节存储长度 选用合适的int类型，比如tinyint 字段尽量NOT NULL 不使用外键、触发器、视图 大文件只存路径 连接配置优化 服务端 增加可用连接数 修改max_connections的大小 及时释放不活动的连接 修改wait_timeout，默认是28800秒 客户端 连接池 硬件 SSD，搭建磁盘阵列，特定的CPU 重启，show processlist查看线程，连接等是否正常 其他 Redis缓存，ES，读写分离，分库分表，分流，限流，MQ削峰填谷，降级 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-04 15:51:48 "},"db/subdb&table.html":{"url":"db/subdb&table.html","title":"分库分表","keywords":"","body":"为什么要分库分表 单表数据量过大时会影响性能 进行表结构操作（如字段，索引）时会锁表，且极其耗时 防止未经优化的SQL触发全表扫描，控制风险 分库分表的方式 垂直切分 单库 表字段太多，将表结构拆分开，比如一张用户表包含姓名、身份证、手机号等基本信息，又包含入职时间、职级、上级领导等公司层面信息，就可以拆分成两张表。 多库 表太多，将表拆分到不同的数据库，比如一个库存用户相关的表，一个库存订单相关的表。 水平切分 单库 表数据太多，将表数据拆分到不同表中，比如每个月产生3000万数据，按月份每个月建一张新表t_order_202101、t_order_202102。。。，这种方式可以解决单表数据量过大的性能问题，但不能解决单机存储的瓶颈问题。 多库 表数据太多，将表数据拆分到不同数据库存储，各个库中的该表结构是一致的。 带来的问题及解决方案 跨库的关联查询 无法使用join或者多表的关联查询。可以通过如下几种方式解决： 字段冗余 把想要关联查询的字段比如用户姓名在订单表中也存一份，一般订单表只存用户ID，这种方式其实违反了第三范式。 第一范式 字段不可再拆分，不能是一些信息的集合，比如联系方式这个字段包含了手机号、邮箱、地址，就违反了第一范式。 第二范式 表的每行可以被唯一的区分，换句话说，字段要完全依赖于主键，比如主键是两个字段订单ID和商品ID联合的，那么商品名称这个字段就只是依赖于主键的一部分（商品ID），就不应该存在该表中。 第三范式 数据不能存在传递关系，换句话说，表不要存不相关的字段，比如订单表只应该有用户ID，不应该有用户姓名。 广播表 所有库都存一份，并通过一些手段保证数据的同步。 应用层的组装 在各个库查询出一定的数据，在应用中重新整合成想要的结果。 排序、分页、函数的计算 order by、limit、max/min/sum/count等函数，都需要先在每个库执行一遍，然后将结果汇总后再进行一遍计算才能得到准确结果。 分布式ID 如果主键是自增类型，会出现ID重复。可以通过UUID或者雪花算法来解决。 分布式事务 另起一篇，单独详述。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-02-22 10:18:50 "},"db/redisstructure.html":{"url":"db/redisstructure.html","title":"Redis数据结构及原理","keywords":"","body":"Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-07 14:43:34 "},"db/redisquestion.html":{"url":"db/redisquestion.html","title":"Redis常见问题","keywords":"","body":"Redis为什么快 基于内存 单线程 没有创建和销毁线程带来的消耗，没有上下文切换带来的消耗，没有线程竞争相关的加锁释放锁死锁等问题，Redis的瓶颈在于内存和网络（一个命令就是一次网络请求），单线程足够了。 多路复用 如何保证Redis与数据库的数据一致性 数据库数据变化，更新缓存还是删除缓存 如果写数据库的值与更新到缓存值是一样的，不需要经过任何的计算，可以马上更新缓存，但是如果对于那种写数据频繁而读数据少的场景并不合适这种解决方案，因为也许还没有查询就被删除或修改了，这样会浪费时间和资源。如果写数据库的值与更新缓存的值不一致，写入缓存中的数据是写数据库的值再经过一系列处理后得到的结果，那就没有必要马上更新缓存，只要删除缓存即可，等到查询的时候再去把计算后得到的结果插入到缓存中。因此一般建议删除缓存。 先操作数据库还是先操作缓存 根据当前业务的场景的容忍性来选择。 最终一致 先更新数据库，再删除缓存，如果删除缓存失败，就不断异步重试 强一致 先删除缓存，再更新数据库，为了解决并发的问题，采用延时双删的策略：先删除缓存，再更新数据库，过一段时间后再删除一次缓存。 缓存雪崩 设置缓存时采用了相同的过期时间，导致缓存在某一个时刻同时失效，或者缓存服务器宕机导致缓存全面失效，请求全部转发到了DB层面。 解决方案 热点数据永不过期 如果发现从缓存中取不到值，那么通过分布式锁避免失效时并发请求全部落到底层的存储系统上，但是这种方式会带来性能上的损耗 通过随机数之类的方式将缓存失效的时间分散，降低每一个缓存过期时间的重复率 如果是因为缓存服务器故障导致的问题，一方面需要保证缓存服务器的高可用，另一方面，应用程序中可以采用多级缓存 缓存击穿 某个缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求就都会打到数据库。 解决方案 热点数据永不过期 如果发现从缓存中取不到值，那么通过分布式锁避免失效时并发请求全部落到底层的存储系统上，但是这种方式会带来性能上的损耗 缓存穿透 查询一个根本不存在的数据，缓存和数据库都不会命中。出于容错的考虑，如果从数据层查不到数据，则不写入缓存，即数据源返回值为 null 时，不缓存 null，那么请求就永远会打到数据库。 解决方案 如果查询数据库也为空，直接设置一个默认值比如\"null\"存放到缓存，并设置一个过期时间如30秒，这样第二次到缓存中获取就有值了，而不会继续访问数据库，在返回这个\"null\"值的时候，应用就可以认为这是不存在的key，结束操作，从而把大量的类似请求挡在了缓存之中。 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BitSet中，不存在的数据将会被拦截掉，从而避免了对底层存储系统的查询压力。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-07 16:30:53 "},"oauth2/websecurityconfigureradapter-yu-resourceserverconfigureradapter.html":{"url":"oauth2/websecurityconfigureradapter-yu-resourceserverconfigureradapter.html","title":"WebSecurityConfigurerAdapter与ResourceServerConfigurerAdapter","keywords":"","body":"WebSecurityConfigurerAdapter与ResourceServerConfigurerAdapter 1.1、spring security的过滤器链 spring security自己有一个叫FilterChainProxy代理类，该类实现了servlet接口。FilterChainProxy内部有一个List filterChains,在spring 的体系里有个order值（int型）越小优先级越高，filterChains是一个依据order的降序集合，优先级高的在前面，而SecurityFilterChain是一个接口也是一个chain，每个chain里有若干个filter，在spring security里一个请求只会被一个filter chain进行处理，也就是spring security通过遍历filterChains这个集合时，只要找到能处理该请求（servlet-path匹配，即uri中去掉context-path的部分）的filter chain就不再进行其他的filter chain匹配。 private List filterChains; private List getFilters(HttpServletRequest request) { Iterator var2 = this.filterChains.iterator(); SecurityFilterChain chain; do { if (!var2.hasNext()) { return null; } chain = (SecurityFilterChain)var2.next(); } while(!chain.matches(request)); // 找到匹配的chain后终止循环 return chain.getFilters(); } 1.2、二者顺序 默认的WebSecurityConfigurerAdapter的order是100 @Order(100) public abstract class WebSecurityConfigurerAdapter 而ResourceServerConfigurerAdapter实现类的@EnableResourceServer里导入了ResourceServerConfiguration， @Import({ResourceServerConfiguration.class}) public @interface EnableResourceServer { 该类里定义了order为3 public class ResourceServerConfiguration extends WebSecurityConfigurerAdapter implements Ordered { private int order = 3; 所以ResourceServerConfigurerAdapter的实现类优先级比另外一个的更高，在请求匹配的情况下以它为准，而WebSecurityConfigurerAdapter的实现类会失效。 如果想让WebSecurityConfigurerAdapter比ResourceServerConfigurerAdapter优先级高的话，只须要让前者的@Order值比后者的@Order值更小就行了。 @Order(1) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { 每声明一个*Adapter的实现类，都会产生一个filterChain。前面讲到一个request（匹配url）只能被一个filterChain处理，所以有二个Adapter的时候，在请求都匹配的情况下，优先级较低的会失效。 1.3、二者同时生效 根本在于让不同的Adapter匹配不同request（url） 实现时将细粒度较粗的优先级设低 @EnableWebSecuritypublic class MultiHttpSecurityConfig { @Configuration @EnableResourceServer public static class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .antMatcher(\"/auth/**\") // 指定该Adapter只处理/auth/**的请求 .authorizeRequests() // 对该路径做更细的权限控制 .antMatchers(\"/admin/**\").hasAuthority(\"ROLE_ADMIN\") .antMatchers(\"/user/**\").hasAuthority(\"ROLE_USER\") .anyRequest().authenticated(); } } @Configuration public static class WebSecurityConfig extends WebSecurityConfigurerAdapter { protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() // 因为它的顺序在上面的Adapter之后，所以实际是对/auth/**外的所有请求做权限的控制 .antMatchers(\"/actutor/**\").permitAll( .antMatchers(\"/admin/**\").hasAuthority(\"ROLE_ADMIN\") .anyRequest() .authenticated(); } } } 1.4、Tips spring security集成Oauth2后有个默认的AuthorizationServerSecurityConfiguration，其order为0，该类是对/oauth/token、/oauth/token_key、/oauth/check_token三个url做处理的 protected void configure(HttpSecurity http) throws Exception { AuthorizationServerSecurityConfigurer configurer = new AuthorizationServerSecurityConfigurer(); FrameworkEndpointHandlerMapping handlerMapping = this.endpoints.oauth2EndpointHandlerMapping(); http.setSharedObject(FrameworkEndpointHandlerMapping.class, handlerMapping); this.configure(configurer); http.apply(configurer); String tokenEndpointPath = handlerMapping.getServletPath(\"/oauth/token\"); String tokenKeyPath = handlerMapping.getServletPath(\"/oauth/token_key\"); String checkTokenPath = handlerMapping.getServletPath(\"/oauth/check_token\"); if (!this.endpoints.getEndpointsConfigurer().isUserDetailsServiceOverride()) { UserDetailsService userDetailsService = (UserDetailsService)http.getSharedObject(UserDetailsService.class); this.endpoints.getEndpointsConfigurer().userDetailsService(userDetailsService); } // /oauth/token的权限写死为fullyAuthenticated // /oauth/token_key、/oauth/check_token的权限则是可配的，默认为denyAll，可在实现AuthorizationServerConfigurerAdapter的配置类中修改 ((RequestMatcherConfigurer)((HttpSecurity)((AuthorizedUrl)((AuthorizedUrl)((AuthorizedUrl)http.authorizeRequests().antMatchers(new String[]{tokenEndpointPath})).fullyAuthenticated().antMatchers(new String[]{tokenKeyPath})).access(configurer.getTokenKeyAccess()).antMatchers(new String[]{checkTokenPath})).access(configurer.getCheckTokenAccess()).and()).requestMatchers().antMatchers(new String[]{tokenEndpointPath, tokenKeyPath, checkTokenPath})).and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); http.setSharedObject(ClientDetailsService.class, this.clientDetailsService); } public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception { oauthServer .tokenKeyAccess(\"permitAll()\") .checkTokenAccess(\"isAuthenticated()\"); } } Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2019-12-31 15:58:40 "},"other/StringConstantPool.html":{"url":"other/StringConstantPool.html","title":"String常量池","keywords":"","body":"String s1 = \"hello\"; String s2 = \"hello\"; String s3 = \"he\" + \"llo\"; String s4 = \"he\" + new String(\"llo\"); String s5 = new String(\"hello\"); String s6 = s5.intern(); String s7 = \"he\"; String s8 = \"llo\"; String s9 = s7 + s8; System.out.println(s1 == s2); // true // 以字面量的形式创建String变量时，JVM会在编译期间就把该字面量\"hello\"放到字符串常量池中，后续再以字面量的形式创建\"hello\"变量时,直接返回该字面量在字符串常量池中的引用，所以s1==s2。 System.out.println(s1 == s3); // true // \"he\" + \"llo\"在编译期间JVM会将其拼接为\"hello\"，如果常量池中没有，就放入字符串常量池中，否则返回该字面量在字符串常量池中的引用，并不会将\"he\"和\"llo\"放入字符串常量池中，所以s1==s3。 System.out.println(s1 == s4); // false // new String(\"llo\")创建了两个对象，\"llo\"存于字符串常量池，new String(\"llo\")存于堆，\"he\" + new String(\"llo\")两个对象的相加编译器不会优化，相加的结果存于堆，所以s1!=s4。 System.out.println(s1 == s9); // false // s7 + s8两个对象的相加编译器不会优化，相加的结果存于堆，所以s1!=s9 System.out.println(s4 == s5); // false // s4和s5是堆中两个不同的对象，所以s4!=s5。 System.out.println(s1 == s6); // true // intern()能使一个位于堆中的字符串在运行期间动态的加入到字符串常量池中（字符串常量池的内容是程序启动的时候就加载进内存了），如果字符串常量池中有该对象对应的字面量，就返回该字面量在字符串常量池中的引用，否则在字符串常量池中创建该对象对应的字面量，将该对象的引用作为该字面量在字符串常量池中的引用并返回。 String s10 = new String(\"hello\") + new String(\"h\"); String s11 = s10.intern(); String s12 = \"helloh\"; System.out.println(s13 == s14); // 生成了5个对象：字符串常量池中的\"hello\"和\"h\",两个在堆中的对象new String(\"hello\")和new String(\"h\")以及它们相加后的对象，intern将\"helloh\"放入字符串常量池中，并将相加后的对象的引用作为字符串常量池中\"helloh\"的引用，所以s14和s13是同一个引用，所以s13==s14。 String s13 = new StringBuilder(\"test\").append(\"this\").toString(); System.out.println(s13 == s13.intern()); // true // s13.intern()将s13的引用作为字面量\"testthis\"的引用存到了常量池 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-04-21 17:29:05 "},"other/interview.html":{"url":"other/interview.html","title":"面试总结","keywords":"","body":"基于ShardingSphere将消息记录表分表及读写分离 读写分离 长连接服务主要提供了消息推送和查询的功能，接入了7个业务线，日均消息量500万左右，一开始只有一张消息记录表，所有业务线的消息都存储在这张表中，后来随着业务的发展，接入的业务线越来越多，每天的消息量越来越多，我们发现有一个业务线只用了长连接，不需要查询，且数据量较大，占用总数据量的70%，所以把它和其他业务线的存储做了分离，代码层面它和其他业务线用的还是同一个逻辑表都叫MESSAGE_RECORD，实际的真实表命名上我们加了后缀作区分，为了保证插入的效率，这张表上面没有加任何索引，而其他业务线存储的表会有一些查询的索引，然后写了一个分片算法，根据业务线判断存到哪张真实表。 分表 后来随着这些业务线的扩张，使用的人员越来越多，每天的消息量也越来越大，只用长连接的那个业务线一天就是300多万的消息，其他业务线加起来也有200万，所以我们开始考虑按月分表，我们改写了之前的分片算法，在基于业务线判断后又基于当前时间将数据存到对应的月份表中。 读 查询的场景主要是根据用户ID分页查他未读、已读和全部的消息，并按时间倒序，如何解决多表的查询、分页和排序问题，之前入库的时候是以业务线和创建时间为分片键的一个分片算法，返回的是写入哪一个数据源，而查询的时候则是以用户ID为分片键的一个分片算法，会返回多个数据源，sharding jdbc会做sql的改写，从多个数据源查到数据后在内存中再做组合归并，最终返回。 解决websocket服务频繁FULL GC的问题 生产上频繁出现Full GC，重启后短时间没问题，超过一定时间后，又开始频繁Full GC，通过mat分析dump文件，发现有一个叫ScheduledThreadPoolExecutor的类下面有个叫DelayedWorkQueue的类下面的RunnableScheduledFuture数组特别大，有898656个ScheduledFutureTask元素，占用了很多空间。 通过查看代码发现ScheduledFutureTask是在长连接建立时用来处理心跳续期的，在开启该任务时会存到一个map（用来存储长连接对应的任务，以便长连接断开时停止该任务）中，但在长连接断掉后关闭该任务时没从map中remove掉，所以这部分对象一直没有被回收，至此定位频繁Full GC的原因就是内存泄漏，增加remove的逻辑，问题解决。 解决MQ广播模式导致的消息处理瓶颈问题 因为推送消息给客户端需要一个Channel对象，这个对象无法被序列化，只能与长连接ID形成一个映射关系存在内存中，在消费业务线mq发来的消息时无法知道消息里面对应的用户和哪些机器建立了长连接，所以刚开始是采用广播模式，每台机器都消费消息，然后去查出redis里面用户的长连接，再去映射关系里寻找Channel，发送消息。但是随着接入业务线的增加，消息量越来越多，高峰时每秒4，500的消息，因为是广播模式，实际相当于只有一台机器在消费，增加机器也没用，消息产生了积压，所以必须要改成集群模式。 为了解决开头提到的问题，新建了一张表存储服务器ID和consumerId的映射关系，首先根据机器数配置相应的consumerId到表中，每台服务器首次部署时会生成一个UUID作为服务器ID，且写到服务器一个目录下，以便下次启动时读取，接着去表中查询没有关联服务器ID的consumerId作为它的consumerId，并把关联关系更新到表中，并指定消费mq的tag为服务器ID。广播模式改成集群模式后，随机一台服务器消费消息，将消息入库，接着找到根据消息里用户去redis找到长连接，进而拿到长连接的服务器ID，将消息重新发到mq中并指定tag，只消费该tag的机器将负责推送消息给客户端。 基于Lua脚本保证心跳续期的原子性 长连接服务的redis总共就两个key，一个存储长连接对应的用户ID、业务线和服务器ID，是个Hash结构，有效期是100秒，一个存储用户ID对应的长连接，是个zset结构，score存的是长连接过期时间的时间戳。建立长连接的时候会生成第一个key并向第二个key中添加元素，之后每隔20秒，前端会往后端发送一个心跳包，后端有一个字段记录心跳的最新事件，会更新该值，同时后端每隔45秒判断一下最近45秒内有没有收到心跳包，如果没有，则认为连接断开，清除redis相关的key并移除zset中对应的长连接，如果有，会延长hash结构的key的过期事件并更新zset中对应长连接的score值，这两步需要保证原子性，所以用了Lua。 持续调优，将单机承载连接数从1000提升至100000； 应用 JVM 通过用mat分析dump和用gcviewer分析gc日志 数据库 分库分表、慢sql持续优化 服务器 调整了每台服务器的系统最大文件句柄数和单进程打开的最大句柄数，它们会限制长连接数 基于Sentinel的限流与降级优先保证核心系统的消息可达性 上面提到的每天300万消息的业务线是核心业务线，且它只用长连接，所以为了保证流量过高时它不会出问题，我们对查询相关的一系列接口做了可限流的配置，流量高峰时提示用户系统繁忙，稍后重试。 多数据源动态加载与扩展插件 配置文件里配置多个数据源的地址、用户名、密码 根据这些配置封装每个数据源对应的DruidDataSource对象，并作为value存放到一个map中，key为这些数据源的名称 把map设置给一个DynamicDataSource对象的targetDataSource属性，在原来返回DataSource的地方返回这个DynamicDataSource对象 维护一个ThreadLocal，存储每个线程对应的DataSource，在切换数据源时set，继承AbstractRoutingDataSource并重写它的determineCurrentLookupKey方法，在方法中从ThreadLocal里get出数据源，mybatis就会使用该数据源。 线程池动态调参插件 继承ThreadPool封装一个带name的ThreadPoolExcutor，并存到一个以name为key，池为value的map中，创建线程池时通过该封装的类创建 在配置中心配置相应name的线程池配置 监听apollo，根据name获取到线程池，通过相关set方法调参，实时生效 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-03-05 17:50:31 "}}