{"./":{"url":"./","title":"索引","keywords":"","body":"索引 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:46:10 "},"designpatterns/creational/factory.html":{"url":"designpatterns/creational/factory.html","title":"工厂","keywords":"","body":"简单工厂模式 又称静态工厂方法模式，工厂类封装new对象的细节，使用者通过传参给工厂类来获得相应对象。 组成： 工厂类角色（一个）：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品。 抽象产品角色（一个）：它一般是具体产品继承的父类或者实现的接口。 具体产品角色（多个）：工厂类所创建的对象就是此角色的实例，在java中由一个具体类实现。 设计原则分析 每增加一种产品，创建一个具体产品角色，产品层面不违背开闭原则，但需要修改工厂类中创建产品的逻辑，工厂层面违背了开闭原则。且随着产品越来越多，工厂职责越来越重，违背了单一职责原则。 如： // 使用者 Logger LOGGER = LoggerFactory.getLogger(WebLogController.class); public static Logger getLogger(Class clazz) { Logger logger = getLogger(clazz.getName()); if (DETECT_LOGGER_NAME_MISMATCH) { Class autoComputedCallingClass = Util.getCallingClass(); if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) { Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(), autoComputedCallingClass.getName())); Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\"); } } return logger; } public static Logger getLogger(String name) { ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name); } // 使用者 Calendar calendar = Calendar.getInstance(); public static Calendar getInstance() { return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT)); } private static Calendar createCalendar(TimeZone zone, Locale aLocale) { CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) { try { return provider.getInstance(zone, aLocale); } catch (IllegalArgumentException iae) { // fall back to the default instantiation } } Calendar cal = null; if (aLocale.hasExtensions()) { String caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) { switch (caltype) { case \"buddhist\": cal = new BuddhistCalendar(zone, aLocale); break; case \"japanese\": cal = new JapaneseImperialCalendar(zone, aLocale); break; case \"gregory\": cal = new GregorianCalendar(zone, aLocale); break; } } } if (cal == null) { // If no known calendar type is explicitly specified, // perform the traditional way to create a Calendar: // create a BuddhistCalendar for th_TH locale, // a JapaneseImperialCalendar for ja_JP_JP locale, or // a GregorianCalendar for any other locales. // NOTE: The language, country and variant strings are interned. if (aLocale.getLanguage() == \"th\" && aLocale.getCountry() == \"TH\") { cal = new BuddhistCalendar(zone, aLocale); } else if (aLocale.getVariant() == \"JP\" && aLocale.getLanguage() == \"ja\" && aLocale.getCountry() == \"JP\") { cal = new JapaneseImperialCalendar(zone, aLocale); } else { cal = new GregorianCalendar(zone, aLocale); } } return cal; } 工厂方法模式 工厂方法模式简单来讲就是简单工厂模式里集中在工厂类上的压力由工厂方法模式里不同的工厂子类来分担。 组成 抽象工厂角色（一个）： 这是本模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在java中它由抽象类或者接口来实现。 具体工厂角色（多个）：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象。 抽象产品角色（一个）：它是具体产品继承的父类或者是实现的接口，在java中一般由抽象类或者接口来实现。 具体产品角色（多个）：具体工厂角色所创建的对象就是此角色的实例，在java中由具体的类来实现。 设计原则分析 当有新的具体产品产生时，只要按照抽象产品角色、抽象工厂角色提供的规则来生成具体产品角色和具体工厂角色，而不必去修改任何已有的代码。可以看出产品和工厂层面都是符合开闭原则的。每个具体工厂角色只负责创建对应的具体产品角色，不违背单一职责原则。 抽象工厂模式 多个抽象产品角色，每个抽象产品角色有多个具体产品角色的情况下，由一个具体工厂角色负责创建一系列相关或相互依赖的具体产品角色，而无需创建多个具体工厂角色。 组成 抽象工厂角色（一个）： 这是本模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在java中它由抽象类或者接口来实现。 具体工厂角色（多个）：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象。 抽象产品角色（多个）：它是具体产品继承的父类或者是实现的接口，在java中一般由抽象类或者接口来实现。 具体产品角色（多个）：具体工厂角色所创建的对象就是此角色的实例，在java中由具体的类来实现。 比如空调这个抽象产品分为美的空调，海尔空调，格力空调，冰箱这个抽象产品分为美的冰箱，海尔冰箱，格力冰箱，洗衣机这个抽象产品分为美的洗衣机，海尔洗衣机，格力洗衣机，像美的空调，美的冰箱，美的洗衣机都属于美的品牌，那么就由一个美的工厂来负责生产这三个产品，而不需要美的空调工厂，美的冰箱工厂，美的洗衣机工厂3个工厂来处理。 设计原则分析 如果加入了一个新的抽象产品，那么从抽象工厂角色到具体工厂角色都要调整，违背了开闭原则。 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-21 10:31:17 "},"designpatterns/creational/singleton.html":{"url":"designpatterns/creational/singleton.html","title":"单例","keywords":"","body":"饿汉式单例 饿汉式单例是在类加载的时候就立即创建对象，绝对线程安全，在线程还没出现以前就实例化了，不会存在访问安全问题，优点是没有锁及复杂逻辑，效率高，缺点是不管使不使用都占着空间，浪费内存。 public class Singleton { private static final Singleton singleton = new Singleton(); private Singleton() {} public static Singleton getInstance() { return singleton; } } public class Singleton { private static Singleton singleton = null; static { singleton = new Singleton(); } private Singleton() {} public static Singleton getInstance() { return singleton; } } 懒汉式单例 懒汉式单例是在获取实例的方法被调用时才创建对象。 public class Singleton { private static Singleton singleton = null; private Singleton() {} // 在线程数量比较多情况下，会导致大批量线程出现阻塞，从而导致程序运行性能大幅下降 public synchronized static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } public class Singleton { private static volatile Singleton singleton = null; private Singleton() {} // 双重检查锁 public static Singleton getInstance() { if (singleton == null) { synchronized (singleton.getClass()) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } public class Singleton { private Singleton() {} public static final Singleton getInstance() { // 调用时才会初始化内部类 return InnerSingleton.singleton; } // 静态内部类 // 这种形式没有饿汉式的内存浪费，也没有synchronized的性能问题 private static class InnerSingleton { private static final Singleton singleton = new Singleton(); } } 破坏单例 反射 Class clazz = Singleton.class; // 通过反射拿到私有的构造方法 Constructor c = clazz.getDeclaredConstructor(null); // 强制访问 c.setAccessible(true); // 暴力初始化 Object o1 = c.newInstance(); Object o2 = Singleton.getInstance(); System.out.println(o1 == o2); // false 解决方法：在单例的构造方法中加以限制： private Singleton() { // 此处的判断作用有： // 1、若不加判断直接抛出异常，则内部类中无法创建实例 // 2、若如上面的代码，在调用单例类提供的获取实例方法之前先暴力初始化， // if里的判断调用了内部类，仍会先初始化内部类， // 内部类在创建实例时到此判断，此时InnerSingleton.singleton为null，创建实例， // 接着继续暴力初始化在此处的判断，InnerSingleton.singleton不为null， // 所以此处InnerSingleton.singleton为null只有一种情况：初始化内部类时创建Singleton实例 if (InnerSingleton.singleton != null) { throw new RuntimeException(\"no permition to new instance\"); } } 序列化与反序列化 Singleton s1 = null; Singleton s2 = Singleton.getInstance(); FileOutputStream fos = new FileOutputStream(\"Singleton.obj\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(s2); oos.flush(); oos.close(); FileInputStream fis = new FileInputStream(\"Singleton.obj\"); ObjectInputStream ois = new ObjectInputStream(fis); s1 = (Singleton)ois.readObject(); ois.close(); System.out.println(s1 == s2); // false 解决方法：在单例类中增加 readResolve()方法 private Singleton readResolve() { return InnerSingleton.singleton; } 至此一个完美的单例诞生： public class Singleton implements Serializable { private Singleton() { // 防止反射破解 if (InnerSingleton.singleton != null) { throw new RuntimeException(\"no permition to new instance\"); } } public static final Singleton getInstance() { // 调用时才会初始化内部类 return InnerSingleton.singleton; } // 静态内部类 // 这种形式没有饿汉式的内存浪费，也没有synchronized的性能问题 private static class InnerSingleton { private static final Singleton singleton = new Singleton(); } // 防止序列化与反序列化破解 private Singleton readResolve() { return InnerSingleton.singleton; } } 原理： ObjectInputStream ois = new ObjectInputStream(fis); s1 = (Singleton)ois.readObject(); public final Object readObject() throws IOException, ClassNotFoundException { if (enableOverride) { return readObjectOverride(); } // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) { throw ex; } if (depth == 0) { vlist.doCallbacks(); } return obj; } finally { passHandle = outerHandle; if (closed && depth == 0) { clear(); } } } private Object readObject0(boolean unshared) throws IOException { ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); ... } private Object readOrdinaryObject(boolean unshared) throws IOException { if (bin.readByte() != TC_OBJECT) { throw new InternalError(); } ObjectStreamClass desc = readClassDesc(false); desc.checkDeserialize(); Class cl = desc.forClass(); if (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) { throw new InvalidClassException(\"invalid class descriptor\"); } Object obj; try { // 就是判断一下构造方法是否为空,只要有无参构造方法就会实例化 obj = desc.isInstantiable() ? desc.newInstance() : null; } catch (Exception ex) { throw (IOException) new InvalidClassException( desc.forClass().getName(), \"unable to create instance\").initCause(ex); } passHandle = handles.assign(unshared ? unsharedMarker : obj); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) { handles.markException(passHandle, resolveEx); } if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } handles.finish(passHandle); if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) // 找到了无参的readResolve() { Object rep = desc.invokeReadResolve(obj); if (unshared && rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } // obj被重新赋值为反射调用readResolve方法得到的返回值 handles.setObject(passHandle, obj = rep); } } return obj; } boolean isInstantiable() { requireInitialized(); return (cons != null); } boolean hasReadResolveMethod() { requireInitialized(); return (readResolveMethod != null); } // ObjectStreamClass(final Class cl)方法中赋值 // 通过反射找到一个无参的readResolve()方法 readResolveMethod = getInheritableMethod( cl, \"readResolve\", null, Object.class); Object invokeReadResolve(Object obj) throws IOException, UnsupportedOperationException { requireInitialized(); if (readResolveMethod != null) { try { return readResolveMethod.invoke(obj, (Object[]) null); } catch (InvocationTargetException ex) { Throwable th = ex.getTargetException(); if (th instanceof ObjectStreamException) { throw (ObjectStreamException) th; } else { throwMiscException(th); throw new InternalError(th); // never reached } } catch (IllegalAccessException ex) { // should not occur, as access checks have been suppressed throw new InternalError(ex); } } else { throw new UnsupportedOperationException(); } } 通过以上的源码分析可以看出，虽然增加 readResolve()方法返回实例，解决了单例被破坏的问题，但是，实际上还是实例化了两次，只不过第一次实例化的对象没有被返回而已。如果创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大，登记式单例将解决这个问题。 登记（注册）式单例 就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。 容器缓存 public class Singleton { public static final Map container = new ConcurrentHashMap<>(); private Singleton(){} public static Object getInstance(String className) { if (!container.containsKey(className)) { synchronized (Singleton.class) { if (!container.containsKey(className)) { try { container.put(className, Class.forName(className).newInstance()); } catch (InstantiationException|IllegalAccessException|ClassNotFoundException e) { e.printStackTrace(); } } } } return container.get(className); } } 枚举登记 public enum Singleton { // 枚举类构造方法默认私有化 // INSTANCE默认为static final INSTANCE; // Singleton.INSTANCE就是Singleton的唯一实例 } 通过工具jad反编译后 public final class Singleton extends Enum { public static Singleton[] values() { return (Singleton[])$VALUES.clone(); } public static Singleton valueOf(String name) { return (Singleton)Enum.valueOf(com/example/demo/Singleton, name); } private Singleton(String s, int i) { super(s, i); } public static final Singleton INSTANCE; private static final Singleton $VALUES[]; static { // 静态代码块中赋值，属于饿汉式 INSTANCE = new Singleton(\"INSTANCE\", 0); $VALUES = (new Singleton[] { INSTANCE }); } } 那么能否通过反射破解呢 public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); } } // 如果是枚举类型直接抛异常 if ((clazz.getModifiers() & Modifier.ENUM) != 0) throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) { ca = acquireConstructorAccessor(); } @SuppressWarnings(\"unchecked\") T inst = (T) ca.newInstance(initargs); return inst; } 能否通过序列化与反序列化破解呢 private Object readObject0(boolean unshared) throws IOException { ... case TC_ENUM: return checkResolve(readEnum(unshared)); ... } private Enum readEnum(boolean unshared) throws IOException { if (bin.readByte() != TC_ENUM) { throw new InternalError(); } ObjectStreamClass desc = readClassDesc(false); if (!desc.isEnum()) { throw new InvalidClassException(\"non-enum class: \" + desc); } int enumHandle = handles.assign(unshared ? unsharedMarker : null); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) { handles.markException(enumHandle, resolveEx); } String name = readString(false); Enum result = null; Class cl = desc.forClass(); if (cl != null) { try { @SuppressWarnings(\"unchecked\") // 通过 Class 对象和类名找到一个唯一的枚举对象,没有创建新的实例 Enum en = Enum.valueOf((Class)cl, name); result = en; } catch (IllegalArgumentException ex) { throw (IOException) new InvalidObjectException( \"enum constant \" + name + \" does not exist in \" + cl).initCause(ex); } if (!unshared) { handles.setObject(enumHandle, result); } } handles.finish(enumHandle); passHandle = enumHandle; return result; } 附：双重检查volatile关键字的必要性 singleton = new Singleton(); 创建了一个对象。这一行代码可以分解为如下的3行伪代码： memory = allocate(); // 1：分配对象的内存空间 ctorInstance(memory); // 2：初始化对象 instance = memory; // 3：设置instance指向刚分配的内存地址 上面3行伪代码中的2和3之间，可能会被重排序（在一些JIT编译器上，这种重排序是真实发生的）。2和3之间重排序之后的执行时序如下： memory = allocate(); // 1：分配对象的内存空间 instance = memory; // 3：设置instance指向刚分配的内存地址 // 注意，此时对象还没有被初始化！ ctorInstance(memory); // 2：初始化对象 根据《The Java Language Specification,Java SE 7 Edition》（后文简称为Java语言规范），所有线程在执行Java程序时必须要遵守intra-thread semantics。intra-thread semantics保证重排序不会改变单线程内的程序执行结果。换句话说，intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。上面3行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反intra-thread semantics。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。 如下图所示，只要保证2排在4的前面，即使2和3之间重排序了，也不会违反intra-thread semantics。 由于单线程内要遵守intra-thread semantics，从而能保证A线程的执行结果不会被改变。但是，当线程A和B按下图的时序执行时，B线程将看到一个还没有被初始化的对象。 回到本文的主题，DoubleCheckedLocking示例代码的第7行（instance=new Singleton();）如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null（因为第4行处没有锁，线程B随时可能进来访问）。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化！ 如下的执行时序，这里A2和A3虽然重排序了，但Java内存模型的intra-thread semantics将确保A2一定会排在 A4前面执行。因此，线程A的intra-thread semantics没有改变，但A2和A3的重排序，将导致线程 B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象。 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-24 17:32:14 "},"designpatterns/creational/prototype.html":{"url":"designpatterns/creational/prototype.html","title":"原型","keywords":"","body":"单例 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:49:10 "},"designpatterns/structure/adapter.html":{"url":"designpatterns/structure/adapter.html","title":"适配器","keywords":"","body":"适配器 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:45 "},"designpatterns/structure/decorator.html":{"url":"designpatterns/structure/decorator.html","title":"装饰者","keywords":"","body":"装饰者 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:47 "},"designpatterns/structure/proxy.html":{"url":"designpatterns/structure/proxy.html","title":"代理","keywords":"","body":"代理 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:48 "},"designpatterns/behavioral/strategy.html":{"url":"designpatterns/behavioral/strategy.html","title":"策略","keywords":"","body":"策略 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:51 "},"designpatterns/behavioral/templatemethod.html":{"url":"designpatterns/behavioral/templatemethod.html","title":"模板方法","keywords":"","body":"模板方法 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:52 "},"designpatterns/behavioral/observer.html":{"url":"designpatterns/behavioral/observer.html","title":"观察者","keywords":"","body":"观察者 Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:50 "},"oauth2/websecurityconfigureradapter-yu-resourceserverconfigureradapter.html":{"url":"oauth2/websecurityconfigureradapter-yu-resourceserverconfigureradapter.html","title":"WebSecurityConfigurerAdapter与ResourceServerConfigurerAdapter","keywords":"","body":"WebSecurityConfigurerAdapter与ResourceServerConfigurerAdapter 1.1、spring security的过滤器链 spring security自己有一个叫FilterChainProxy代理类，该类实现了servlet接口。FilterChainProxy内部有一个List filterChains,在spring 的体系里有个order值（int型）越小优先级越高，filterChains是一个依据order的降序集合，优先级高的在前面，而SecurityFilterChain是一个接口也是一个chain，每个chain里有若干个filter，在spring security里一个请求只会被一个filter chain进行处理，也就是spring security通过遍历filterChains这个集合时，只要找到能处理该请求（servlet-path匹配，即uri中去掉context-path的部分）的filter chain就不再进行其他的filter chain匹配。 private List filterChains; private List getFilters(HttpServletRequest request) { Iterator var2 = this.filterChains.iterator(); SecurityFilterChain chain; do { if (!var2.hasNext()) { return null; } chain = (SecurityFilterChain)var2.next(); } while(!chain.matches(request)); // 找到匹配的chain后终止循环 return chain.getFilters(); } 1.2、二者顺序 默认的WebSecurityConfigurerAdapter的order是100 @Order(100) public abstract class WebSecurityConfigurerAdapter 而ResourceServerConfigurerAdapter实现类的@EnableResourceServer里导入了ResourceServerConfiguration， @Import({ResourceServerConfiguration.class}) public @interface EnableResourceServer { 该类里定义了order为3 public class ResourceServerConfiguration extends WebSecurityConfigurerAdapter implements Ordered { private int order = 3; 所以ResourceServerConfigurerAdapter的实现类优先级比另外一个的更高，在请求匹配的情况下以它为准，而WebSecurityConfigurerAdapter的实现类会失效。 如果想让WebSecurityConfigurerAdapter比ResourceServerConfigurerAdapter优先级高的话，只须要让前者的@Order值比后者的@Order值更小就行了。 @Order(1) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { 每声明一个*Adapter的实现类，都会产生一个filterChain。前面讲到一个request（匹配url）只能被一个filterChain处理，所以有二个Adapter的时候，在请求都匹配的情况下，优先级较低的会失效。 1.3、二者同时生效 根本在于让不同的Adapter匹配不同request（url） 实现时将细粒度较粗的优先级设低 @EnableWebSecuritypublic class MultiHttpSecurityConfig { @Configuration @EnableResourceServer public static class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .antMatcher(\"/auth/**\") // 指定该Adapter只处理/auth/**的请求 .authorizeRequests() // 对该路径做更细的权限控制 .antMatchers(\"/admin/**\").hasAuthority(\"ROLE_ADMIN\") .antMatchers(\"/user/**\").hasAuthority(\"ROLE_USER\") .anyRequest().authenticated(); } } @Configuration public static class WebSecurityConfig extends WebSecurityConfigurerAdapter { protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() // 因为它的顺序在上面的Adapter之后，所以实际是对/auth/**外的所有请求做权限的控制 .antMatchers(\"/actutor/**\").permitAll( .antMatchers(\"/admin/**\").hasAuthority(\"ROLE_ADMIN\") .anyRequest() .authenticated(); } } } 1.4、Tips spring security集成Oauth2后有个默认的AuthorizationServerSecurityConfiguration，其order为0，该类是对/oauth/token、/oauth/token_key、/oauth/check_token三个url做处理的 protected void configure(HttpSecurity http) throws Exception { AuthorizationServerSecurityConfigurer configurer = new AuthorizationServerSecurityConfigurer(); FrameworkEndpointHandlerMapping handlerMapping = this.endpoints.oauth2EndpointHandlerMapping(); http.setSharedObject(FrameworkEndpointHandlerMapping.class, handlerMapping); this.configure(configurer); http.apply(configurer); String tokenEndpointPath = handlerMapping.getServletPath(\"/oauth/token\"); String tokenKeyPath = handlerMapping.getServletPath(\"/oauth/token_key\"); String checkTokenPath = handlerMapping.getServletPath(\"/oauth/check_token\"); if (!this.endpoints.getEndpointsConfigurer().isUserDetailsServiceOverride()) { UserDetailsService userDetailsService = (UserDetailsService)http.getSharedObject(UserDetailsService.class); this.endpoints.getEndpointsConfigurer().userDetailsService(userDetailsService); } // /oauth/token的权限写死为fullyAuthenticated // /oauth/token_key、/oauth/check_token的权限则是可配的，默认为denyAll，可在实现AuthorizationServerConfigurerAdapter的配置类中修改 ((RequestMatcherConfigurer)((HttpSecurity)((AuthorizedUrl)((AuthorizedUrl)((AuthorizedUrl)http.authorizeRequests().antMatchers(new String[]{tokenEndpointPath})).fullyAuthenticated().antMatchers(new String[]{tokenKeyPath})).access(configurer.getTokenKeyAccess()).antMatchers(new String[]{checkTokenPath})).access(configurer.getCheckTokenAccess()).and()).requestMatchers().antMatchers(new String[]{tokenEndpointPath, tokenKeyPath, checkTokenPath})).and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); http.setSharedObject(ClientDetailsService.class, this.clientDetailsService); } public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception { oauthServer .tokenKeyAccess(\"permitAll()\") .checkTokenAccess(\"isAuthenticated()\"); } } Copyright © cwcaowei 2020 all right reserved，powered by Gitbook该文章修改时间： 2019-12-31 15:58:40 "}}