{"./":{"url":"./","title":"索引","keywords":"","body":"索引 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:46:10 "},"algorithm/dataStructure.html":{"url":"algorithm/dataStructure.html","title":"数据结构","keywords":"","body":"散列表（哈希表） 一种Key-Value映射形式的存储结构，通过Key查找Value的时间复杂度接近于O (1)，因为其本质上是一个数组，通过哈希函数将Key转换成数组下标，不同的Key转换成的下标有可能是相同的，这种情况叫做哈希冲突，通过有如下两种方式解决： 开放寻址法 当冲突时，寻找一个其他的位置，若该位置还没有元素，则使用该位置，否则继续寻找，ThreaLocal就是这样 链表法 数组的每一个元素都是一个链表的头节点，当冲突时，将新的Value插入到链表尾部，JDK1.7的HashMap就是这样 链表 单向链表 每个节点包含存储的数据和指向下一个节点的指针next，第一个叫头节点，最后一个叫尾节点，尾节点的next指向null 双向链表 每个节点包含存储的数据和指向下一个节点的指针next，同时还有个指向前置节点的prev指针，除了尾节点的next指向null，头节点的prev也指向null 树 基本术语 祖先节点 沿树根到某一节点路径上的所有节点都是这个节点的祖先节点 子孙节点 某个节点子树中的所有节点都是这个节点的子孙节点 子节点 又称孩子节点 子树 节点下面一个子节点即为一个子树 节点的度 节点的子树个数 树的度 树的所有节点中最大的度 树的深度 根在1层，其他节点的层数是父节点的层数+1，最大的层数即为树的深度 边 除了根节点，每个节点都有一条通往上个节点的边，所以N个节点的树有N-1条边 二叉树 一种每个节点最多有2个孩子节点的树，一个叫左孩子，一个叫右孩子，有如下几个性质： 第k层的最大节点数为2的k-1次方 深度为k的树的最大节点数为2的k次方-1 若n0表示叶子节点的个数，n1表示度为1的节点的个数，n2表示度为2的节点的个数，则n0=n2+1 满二叉树 所有非叶子节点都有左右两个孩子节点，且所有叶子节点都在同一层 完全二叉树 对一个有n个节点的二叉树，按层级及从左到右的顺序编号，如果这个树的所有节点和同样深度的满二叉树的编号的节点位置相同，即为完全二叉树，如下图，从1到12节点，完全二叉树的节点位置和满二叉树一致，类似一种子集的概念 二叉查找树 又称二叉排序树，主要有如下几个性质： 若左子树不为空，则左子树上所有节点的值均小于根节点的值 若右子树不为空，则右子树上所有节点的值均大于根节点的值 左、右子树也都是二叉查找树 搜索节点的时间复杂度为O(logn) 二叉堆 本质上是一个完全二叉树，根节点称为堆顶，分为两种类型 最大堆 任何一个父节点的值都大于等于它的左右孩子节点的值 最小堆 任何一个父节点的值都小于等于它的左右孩子节点的值 二叉树的遍历 深度优先遍历 前序遍历 顺序为根节点，左子树，右子树 public static void DLR(TreeNode root) { System.out.println(root); DLR(root.getLeftChild()); DLR(root.getRightChild()); } 中序遍历 顺序为左子树，根节点，右子树 public static void DLR(TreeNode root) { DLR(root.getLeftChild()); System.out.println(root); DLR(root.getRightChild()); } 后序遍历 顺序为左子树，右子树，根节点 public static void DLR(TreeNode root) { DLR(root.getLeftChild()); DLR(root.getRightChild()); System.out.println(root); } 广度优先遍历 层序遍历 顺序为从根节点到叶子节点，从左至右 public static void levelTraversal(TreeNode root) { Queue queue = new LinkedList<>(); // 根节点入队 queue.offer(root); while (!queue.isEmpty()) { // 队首出队 TreeNode node = queue.poll(); System.out.println(node); if (node.getLeftChild() != null) { // 左孩子入队 queue.offer(node.getLeftChild()); } if (node.getRightChild() != null) { // 右孩子入队 queue.offer(node.getRightChild()); } } } 优先队列 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-12-23 23:24:03 "},"algorithm/mergeSortedList.html":{"url":"algorithm/mergeSortedList.html","title":"合并有序链表","keywords":"","body":"合并有序链表 LeetCode第21题 非递归解法 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 若某个链表为空，则直接返回另一个链表 if (l1 == null) { return l2; } if (l2 == null) { return l1; } // 定义一个哑结点 ListNode dummy = new ListNode(0); // 定义一个指针，该指针永远指向结果链表的尾节点 ListNode cur = dummy; // 遍历两个链表 while(l1 != null && l2 != null) { // 取较小的那个值作为新节点添加 if (l1.val > l2.val) { cur.next = new ListNode(l2.val); l2 = l2.next; } else { cur.next = new ListNode(l1.val); l1 = l1.next; } cur = cur.next; } // 剩下不为空的节点直接添加 cur.next = l1 != null ? l1 : l2; return dummy.next; } 该实现有几行比较关键 ListNode cur = dummy; ... cur = cur.next 1、开始时只有一个哑结点，cur指向的是结果链表的尾节点，只是因为结果链表只有一个节点，所以看似指向哑结点 2、当添加一个较小的节点后，cur指向了新的尾节点 3、cur不断的指向尾节点，是为了cur.next = new ListNode(...);能不断的添加节点至结果链表 递归解法 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 若某个链表为空，则直接返回另一个链表 if (l1 == null) { return l2; } if (l2 == null) { return l1; } if (l1.val Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-01-05 21:17:16 "},"algorithm/oddEvenList.html":{"url":"algorithm/oddEvenList.html","title":"奇偶链表","keywords":"","body":"奇偶链表 LeetCode第328题 LeetCode第86题 public ListNode oddEvenList(ListNode head) { // 没有节点或只有一个节点的链表，直接返回 if (head == null || head.next == null) { return head; } // 奇数链表哑结点 ListNode odd = new ListNode(0); // 奇数链表指针 ListNode oddCur = odd; // 偶数链表哑结点 ListNode even = new ListNode(0); // 偶数链表指针 ListNode evenCur = even; int index = 1; // 遍历链表 while (head != null) { if (index % 2 != 0) { // 将节点加入奇数链表 oddCur.next = head; // 奇数链表指针后移 oddCur = oddCur.next; } else { // 将节点加入偶数链表 evenCur.next = head; // 偶数链表指针后移 evenCur = evenCur.next; } index++; head = head.next; } // 偶数链表尾节点后面接个null evenCur.next = null; // 将偶数链表接到奇数链表后面 oddCur.next = even.next; return odd.next; } Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2021-01-06 23:55:19 "},"designpatterns/creational/factory.html":{"url":"designpatterns/creational/factory.html","title":"工厂","keywords":"","body":"简单工厂模式 又称静态工厂方法模式，工厂类封装new对象的细节，使用者通过传参给工厂类来获得相应对象。 组成： 工厂类角色（一个）：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品。 抽象产品角色（一个）：它一般是具体产品继承的父类或者实现的接口。 具体产品角色（多个）：工厂类所创建的对象就是此角色的实例，在java中由一个具体类实现。 设计原则分析 每增加一种产品，创建一个具体产品角色，产品层面不违背开闭原则，但需要修改工厂类中创建产品的逻辑，工厂层面违背了开闭原则。且随着产品越来越多，工厂职责越来越重，违背了单一职责原则。 如： // 使用者 Logger LOGGER = LoggerFactory.getLogger(WebLogController.class); public static Logger getLogger(Class clazz) { Logger logger = getLogger(clazz.getName()); if (DETECT_LOGGER_NAME_MISMATCH) { Class autoComputedCallingClass = Util.getCallingClass(); if (autoComputedCallingClass != null && nonMatchingClasses(clazz, autoComputedCallingClass)) { Util.report(String.format(\"Detected logger name mismatch. Given name: \\\"%s\\\"; computed name: \\\"%s\\\".\", logger.getName(), autoComputedCallingClass.getName())); Util.report(\"See \" + LOGGER_NAME_MISMATCH_URL + \" for an explanation\"); } } return logger; } public static Logger getLogger(String name) { ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name); } // 使用者 Calendar calendar = Calendar.getInstance(); public static Calendar getInstance() { return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT)); } private static Calendar createCalendar(TimeZone zone, Locale aLocale) { CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) { try { return provider.getInstance(zone, aLocale); } catch (IllegalArgumentException iae) { // fall back to the default instantiation } } Calendar cal = null; if (aLocale.hasExtensions()) { String caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) { switch (caltype) { case \"buddhist\": cal = new BuddhistCalendar(zone, aLocale); break; case \"japanese\": cal = new JapaneseImperialCalendar(zone, aLocale); break; case \"gregory\": cal = new GregorianCalendar(zone, aLocale); break; } } } if (cal == null) { // If no known calendar type is explicitly specified, // perform the traditional way to create a Calendar: // create a BuddhistCalendar for th_TH locale, // a JapaneseImperialCalendar for ja_JP_JP locale, or // a GregorianCalendar for any other locales. // NOTE: The language, country and variant strings are interned. if (aLocale.getLanguage() == \"th\" && aLocale.getCountry() == \"TH\") { cal = new BuddhistCalendar(zone, aLocale); } else if (aLocale.getVariant() == \"JP\" && aLocale.getLanguage() == \"ja\" && aLocale.getCountry() == \"JP\") { cal = new JapaneseImperialCalendar(zone, aLocale); } else { cal = new GregorianCalendar(zone, aLocale); } } return cal; } 工厂方法模式 工厂方法模式简单来讲就是简单工厂模式里集中在工厂类上的压力由工厂方法模式里不同的工厂子类来分担。 组成 抽象工厂角色（一个）： 这是本模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在java中它由抽象类或者接口来实现。 具体工厂角色（多个）：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象。 抽象产品角色（一个）：它是具体产品继承的父类或者是实现的接口，在java中一般由抽象类或者接口来实现。 具体产品角色（多个）：具体工厂角色所创建的对象就是此角色的实例，在java中由具体的类来实现。 设计原则分析 当有新的具体产品产生时，只要按照抽象产品角色、抽象工厂角色提供的规则来生成具体产品角色和具体工厂角色，而不必去修改任何已有的代码。可以看出产品和工厂层面都是符合开闭原则的。每个具体工厂角色只负责创建对应的具体产品角色，不违背单一职责原则。 抽象工厂模式 多个抽象产品角色，每个抽象产品角色有多个具体产品角色的情况下，由一个具体工厂角色负责创建一系列相关或相互依赖的具体产品角色，而无需创建多个具体工厂角色。 组成 抽象工厂角色（一个）： 这是本模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类，在java中它由抽象类或者接口来实现。 具体工厂角色（多个）：它含有和具体业务逻辑有关的代码，由应用程序调用以创建对应的具体产品的对象。 抽象产品角色（多个）：它是具体产品继承的父类或者是实现的接口，在java中一般由抽象类或者接口来实现。 具体产品角色（多个）：具体工厂角色所创建的对象就是此角色的实例，在java中由具体的类来实现。 比如空调这个抽象产品分为美的空调，海尔空调，格力空调，冰箱这个抽象产品分为美的冰箱，海尔冰箱，格力冰箱，洗衣机这个抽象产品分为美的洗衣机，海尔洗衣机，格力洗衣机，像美的空调，美的冰箱，美的洗衣机都属于美的品牌，那么就由一个美的工厂来负责生产这三个产品，而不需要美的空调工厂，美的冰箱工厂，美的洗衣机工厂3个工厂来处理。 设计原则分析 如果加入了一个新的抽象产品，那么从抽象工厂角色到具体工厂角色都要调整，违背了开闭原则。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-21 10:31:17 "},"designpatterns/creational/singleton.html":{"url":"designpatterns/creational/singleton.html","title":"单例","keywords":"","body":"饿汉式单例 饿汉式单例是在类加载的时候就立即创建对象，绝对线程安全，在线程还没出现以前就实例化了，不会存在访问安全问题，优点是没有锁及复杂逻辑，效率高，缺点是不管使不使用都占着空间，浪费内存。 public class Singleton { private static final Singleton singleton = new Singleton(); private Singleton() {} public static Singleton getInstance() { return singleton; } } public class Singleton { private static Singleton singleton = null; static { singleton = new Singleton(); } private Singleton() {} public static Singleton getInstance() { return singleton; } } 懒汉式单例 懒汉式单例是在获取实例的方法被调用时才创建对象。 public class Singleton { private static Singleton singleton = null; private Singleton() {} // 在线程数量比较多情况下，会导致大批量线程出现阻塞，从而导致程序运行性能大幅下降 public synchronized static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } public class Singleton { private static volatile Singleton singleton = null; private Singleton() {} // 双重检查锁 public static Singleton getInstance() { if (singleton == null) { synchronized (singleton.getClass()) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } public class Singleton { private Singleton() {} public static final Singleton getInstance() { // 调用时才会初始化内部类 return InnerSingleton.singleton; } // 静态内部类 // 这种形式没有饿汉式的内存浪费，也没有synchronized的性能问题 private static class InnerSingleton { private static final Singleton singleton = new Singleton(); } } 破坏单例 反射 Class clazz = Singleton.class; // 通过反射拿到私有的构造方法 Constructor c = clazz.getDeclaredConstructor(null); // 强制访问 c.setAccessible(true); // 暴力初始化 Object o1 = c.newInstance(); Object o2 = Singleton.getInstance(); System.out.println(o1 == o2); // false 解决方法：在单例的构造方法中加以限制： private Singleton() { // 此处的判断作用有： // 1、若不加判断直接抛出异常，则内部类中无法创建实例 // 2、若如上面的代码，在调用单例类提供的获取实例方法之前先暴力初始化， // if里的判断调用了内部类，仍会先初始化内部类， // 内部类在创建实例时到此判断，此时InnerSingleton.singleton为null，创建实例， // 接着继续暴力初始化在此处的判断，InnerSingleton.singleton不为null， // 所以此处InnerSingleton.singleton为null只有一种情况：初始化内部类时创建Singleton实例 if (InnerSingleton.singleton != null) { throw new RuntimeException(\"no permition to new instance\"); } } 序列化与反序列化 Singleton s1 = null; Singleton s2 = Singleton.getInstance(); FileOutputStream fos = new FileOutputStream(\"Singleton.obj\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(s2); oos.flush(); oos.close(); FileInputStream fis = new FileInputStream(\"Singleton.obj\"); ObjectInputStream ois = new ObjectInputStream(fis); s1 = (Singleton)ois.readObject(); ois.close(); System.out.println(s1 == s2); // false 解决方法：在单例类中增加 readResolve()方法 private Singleton readResolve() { return InnerSingleton.singleton; } 至此一个完美的单例诞生： public class Singleton implements Serializable { private Singleton() { // 防止反射破解 if (InnerSingleton.singleton != null) { throw new RuntimeException(\"no permition to new instance\"); } } public static final Singleton getInstance() { // 调用时才会初始化内部类 return InnerSingleton.singleton; } // 静态内部类 // 这种形式没有饿汉式的内存浪费，也没有synchronized的性能问题 private static class InnerSingleton { private static final Singleton singleton = new Singleton(); } // 防止序列化与反序列化破解 private Singleton readResolve() { return InnerSingleton.singleton; } } 原理： ObjectInputStream ois = new ObjectInputStream(fis); s1 = (Singleton)ois.readObject(); public final Object readObject() throws IOException, ClassNotFoundException { if (enableOverride) { return readObjectOverride(); } // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false); handles.markDependency(outerHandle, passHandle); ClassNotFoundException ex = handles.lookupException(passHandle); if (ex != null) { throw ex; } if (depth == 0) { vlist.doCallbacks(); } return obj; } finally { passHandle = outerHandle; if (closed && depth == 0) { clear(); } } } private Object readObject0(boolean unshared) throws IOException { ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); ... } private Object readOrdinaryObject(boolean unshared) throws IOException { if (bin.readByte() != TC_OBJECT) { throw new InternalError(); } ObjectStreamClass desc = readClassDesc(false); desc.checkDeserialize(); Class cl = desc.forClass(); if (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) { throw new InvalidClassException(\"invalid class descriptor\"); } Object obj; try { // 就是判断一下构造方法是否为空,只要有无参构造方法就会实例化 obj = desc.isInstantiable() ? desc.newInstance() : null; } catch (Exception ex) { throw (IOException) new InvalidClassException( desc.forClass().getName(), \"unable to create instance\").initCause(ex); } passHandle = handles.assign(unshared ? unsharedMarker : obj); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) { handles.markException(passHandle, resolveEx); } if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } handles.finish(passHandle); if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) // 找到了无参的readResolve() { Object rep = desc.invokeReadResolve(obj); if (unshared && rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } // obj被重新赋值为反射调用readResolve方法得到的返回值 handles.setObject(passHandle, obj = rep); } } return obj; } boolean isInstantiable() { requireInitialized(); return (cons != null); } boolean hasReadResolveMethod() { requireInitialized(); return (readResolveMethod != null); } // ObjectStreamClass(final Class cl)方法中赋值 // 通过反射找到一个无参的readResolve()方法 readResolveMethod = getInheritableMethod( cl, \"readResolve\", null, Object.class); Object invokeReadResolve(Object obj) throws IOException, UnsupportedOperationException { requireInitialized(); if (readResolveMethod != null) { try { return readResolveMethod.invoke(obj, (Object[]) null); } catch (InvocationTargetException ex) { Throwable th = ex.getTargetException(); if (th instanceof ObjectStreamException) { throw (ObjectStreamException) th; } else { throwMiscException(th); throw new InternalError(th); // never reached } } catch (IllegalAccessException ex) { // should not occur, as access checks have been suppressed throw new InternalError(ex); } } else { throw new UnsupportedOperationException(); } } 通过以上的源码分析可以看出，虽然增加 readResolve()方法返回实例，解决了单例被破坏的问题，但是，实际上还是实例化了两次，只不过第一次实例化的对象没有被返回而已。如果创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大，登记式单例将解决这个问题。 登记（注册）式单例 就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。 容器缓存 public class Singleton { public static final Map container = new ConcurrentHashMap<>(); private Singleton(){} public static Object getInstance(String className) { if (!container.containsKey(className)) { synchronized (Singleton.class) { if (!container.containsKey(className)) { try { container.put(className, Class.forName(className).newInstance()); } catch (InstantiationException|IllegalAccessException|ClassNotFoundException e) { e.printStackTrace(); } } } } return container.get(className); } } 枚举登记 public enum Singleton { // 枚举类构造方法默认私有化 // INSTANCE默认为static final INSTANCE; // Singleton.INSTANCE就是Singleton的唯一实例 } 通过工具jad反编译后 public final class Singleton extends Enum { public static Singleton[] values() { return (Singleton[])$VALUES.clone(); } public static Singleton valueOf(String name) { return (Singleton)Enum.valueOf(com/example/demo/Singleton, name); } private Singleton(String s, int i) { super(s, i); } public static final Singleton INSTANCE; private static final Singleton $VALUES[]; static { // 静态代码块中赋值，属于饿汉式 INSTANCE = new Singleton(\"INSTANCE\", 0); $VALUES = (new Singleton[] { INSTANCE }); } } 那么能否通过反射破解呢 public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); } } // 如果是枚举类型直接抛异常 if ((clazz.getModifiers() & Modifier.ENUM) != 0) throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) { ca = acquireConstructorAccessor(); } @SuppressWarnings(\"unchecked\") T inst = (T) ca.newInstance(initargs); return inst; } 能否通过序列化与反序列化破解呢 private Object readObject0(boolean unshared) throws IOException { ... case TC_ENUM: return checkResolve(readEnum(unshared)); ... } private Enum readEnum(boolean unshared) throws IOException { if (bin.readByte() != TC_ENUM) { throw new InternalError(); } ObjectStreamClass desc = readClassDesc(false); if (!desc.isEnum()) { throw new InvalidClassException(\"non-enum class: \" + desc); } int enumHandle = handles.assign(unshared ? unsharedMarker : null); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) { handles.markException(enumHandle, resolveEx); } String name = readString(false); Enum result = null; Class cl = desc.forClass(); if (cl != null) { try { @SuppressWarnings(\"unchecked\") // 通过 Class 对象和类名找到一个唯一的枚举对象,没有创建新的实例 Enum en = Enum.valueOf((Class)cl, name); result = en; } catch (IllegalArgumentException ex) { throw (IOException) new InvalidObjectException( \"enum constant \" + name + \" does not exist in \" + cl).initCause(ex); } if (!unshared) { handles.setObject(enumHandle, result); } } handles.finish(enumHandle); passHandle = enumHandle; return result; } 附：双重检查volatile关键字的必要性 singleton = new Singleton(); 创建了一个对象。这一行代码可以分解为如下的3行伪代码： memory = allocate(); // 1：分配对象的内存空间 ctorInstance(memory); // 2：初始化对象 instance = memory; // 3：设置instance指向刚分配的内存地址 上面3行伪代码中的2和3之间，可能会被重排序（在一些JIT编译器上，这种重排序是真实发生的）。2和3之间重排序之后的执行时序如下： memory = allocate(); // 1：分配对象的内存空间 instance = memory; // 3：设置instance指向刚分配的内存地址 // 注意，此时对象还没有被初始化！ ctorInstance(memory); // 2：初始化对象 根据《The Java Language Specification,Java SE 7 Edition》（后文简称为Java语言规范），所有线程在执行Java程序时必须要遵守intra-thread semantics。intra-thread semantics保证重排序不会改变单线程内的程序执行结果。换句话说，intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。上面3行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反intra-thread semantics。这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。 如下图所示，只要保证2排在4的前面，即使2和3之间重排序了，也不会违反intra-thread semantics。 由于单线程内要遵守intra-thread semantics，从而能保证A线程的执行结果不会被改变。但是，当线程A和B按下图的时序执行时，B线程将看到一个还没有被初始化的对象。 回到本文的主题，DoubleCheckedLocking示例代码的第7行（instance=new Singleton();）如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null（因为第4行处没有锁，线程B随时可能进来访问）。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化！ 如下的执行时序，这里A2和A3虽然重排序了，但Java内存模型的intra-thread semantics将确保A2一定会排在 A4前面执行。因此，线程A的intra-thread semantics没有改变，但A2和A3的重排序，将导致线程 B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-04 10:41:39 "},"designpatterns/creational/prototype.html":{"url":"designpatterns/creational/prototype.html","title":"原型","keywords":"","body":"概念 核心在于拷贝原型对象。当对象的构建过程比较耗时时，以一个已存在的对象为原型，基于内存二进制流进行拷贝，无需再经历耗时的对象初始化过程（调用构造函数），性能提升许多。 适用场景 类初始化消耗资源较多 new产生的一个对象需要非常繁琐的过程（new之后需要初始化一些数据） 构造函数复杂 循环体中产生大量对象时 组成 抽象原型（Prototype）：规定拷贝方法 public interface IPrototype { T clone(); } 具体原型（Concrete Prototype）：被拷贝的对象 @Data public class ConcretePrototype implements IPrototype { private int age; private String name; @Override public ConcretePrototype clone() { ConcretePrototype concretePrototype = new ConcretePrototype(); concretePrototype.setAge(this.age); concretePrototype.setName(this.name); return concretePrototype; } } 客户端（Client）：通过拷贝的方式创建对象 public static void main(String[] args) { // 创建原型对象 ConcretePrototype prototype = new ConcretePrototype(); prototype.setAge(18); prototype.setName(\"Tom\"); // 拷贝原型对象 ConcretePrototype cloneType = prototype.clone(); } Object中的clone()与Cloneable接口 以上是原型模式最基本的写法，实际上抽象原型不需要自己定义，所有类的父类Object中有一个native方法clone()，JDK提供了一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在jvm中，只有实现了这个接口的类才可以通过clone()被拷贝，否则在运行时会抛出CloneNotSupportedException异常。基于此，具体原型的实现如下： @Data public class ConcretePrototype implements Cloneable { private int age; private String name; @Override public ConcretePrototype clone() { try { return (ConcretePrototype)super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } 深克隆与浅克隆 浅克隆 以上具体原型对象中的属性只是基本数据类型，但如果是引用类型呢，比如List，会发现在克隆对象的list中新增一个元素，原型对象里的list也会跟着新增，显然对于引用类型的对象，并未在内存中开辟一块新的空间，并拷贝数据，原型对象与克隆对象的引用类型的变量指向的是同一个内存地址，这就是浅克隆。或者说克隆对象的改变会导致原型对象的改变就是浅克隆。因此对基础数据类型及它们的封装类和String的克隆都是深克隆。 深克隆 实现引用类型的对象的实际拷贝，原型对象与克隆对象完全独立。 序列化 @Data public class ConcretePrototype implements Cloneable { private int age; private String name; @Override public ConcretePrototype clone() { try { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (ConcretePrototype)ois.readObject(); } catch (Exception e) { e.printStackTrace(); return null; } } } JSON 手动复制 原型模式与单例模式 原型模式与单例模式是互相对立的。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-02 17:17:36 "},"designpatterns/creational/builder.html":{"url":"designpatterns/creational/builder.html","title":"建造者","keywords":"","body":"适用场景 创建对象需要很多步骤，但是步骤的顺序不一定固定 对象有非常复杂的内部结构（很多属性） 对象的很多参数都有默认值 组成 产品（Product）：要创建的对象 @Data public class User { private String name; private Integer age; private String email; private String phone; private String role; private String idCard; private String address; private String company; } 建造者抽象（Builder）：建造者的抽象类，规范产品对象的各个组成部分的建造，由子类实现具体的建造过程 public interface IBuilder { T build(); } 建造者（Concrete Builder）：具体的Builder类，根据不同的业务逻辑，具体化对象的各个组成部分的创建 public class UserBuilder implements IBuilder { private User user = new User(); public UserBuilder name(String name) { user.setName(name); return this; } public UserBuilder age(Integer age) { user.setAge(age); return this; } ... public User build() { return user; } } 调用者（Director）：调用具体的建造者，负责对象各部分完整创建或按某种顺序创建 User user = new UserBuilder() .name(\"zhangsan\") .age(20) .role(\"admin\") .company(\"ALI\") .email(\"test@test.com.cn\") .phone(\"1811111111\") .idCard(\"32123213123123123\") .address(\"某某路2号\") .build(); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-06 10:48:20 "},"designpatterns/structure/adapter.html":{"url":"designpatterns/structure/adapter.html","title":"适配器","keywords":"","body":"概念 又叫变压器模式，通过一个中间层将一个与客户端的期望不匹配的接口转换为匹配的另一个接口 组成 以家用的220V交流电需要转化为手机充电用的5V直流电为例 目标角色（Target）：期望接口 public interface DC5 { int outputDC5V(); } 源角色（Adaptee）：内容满足需求但不匹配的接口 public class AC220 { public int outputAC220V() { return 220; } } 适配器（Adapter）：将源角色转换为目标角色的实例 类适配器 让Adapter继承Adaptee并实现Target，在具体的实现方法中做转换 public class PowerAdapter extends AC220 implements DC5 { @Override public int output5V() { return super.outputAC220V() / 44; } } 对象适配器 让Adapter实现Target并内部持有Adaptee的引用，在Target接口规定的方法内转换Adaptee public class PowerAdapter implements DC5 { private AC220 ac220; public PowerAdapter(AC220 ac220) { this.ac220 = ac220; } @Override public int output5V() { return ac220.outputAC220V() / 44; } } 接口适配器 当不需要全部实现接口提供的方法时，可先设计一个抽象类（适配器）实现接口，并为该接口中每个方法提供一个默认实现/空实现，那么原先需要实现该接口的类改为继承抽象类同时可有选择的覆盖父类的某些方法来实现需求，匿名内部类是一种常见的形式 public interface InterfaceA { void metho1(); void metho2(); void metho3(); void metho4(); void metho5(); } public abstract class Adapter implements InterfaceA { @Override public void metho1() {} @Override public void metho2() {} @Override public void metho3() {} @Override public void metho4() {} @Override public void metho5() {} } Adapter adapter = new Adapter() { @Override public void method1() { System.out.println(\"\"); } }; adapter.method1(); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-08-17 19:14:40 "},"designpatterns/structure/decorator.html":{"url":"designpatterns/structure/decorator.html","title":"装饰者","keywords":"","body":"概念 在不改变原有对象的基础上，将功能附加到对象上，透明且动态的扩展类的功能。 组成 抽象组件（Component）：一个接口/抽象类，充当被装饰类的原始对象，规定了被装饰对象的行为。 public interface Cake { String getType(); int getPrice(); } 具体组件（Concrete Component）：实现/继承Component的一个具体对象，也是被装饰对象。 public class BaseCake implements Cake { @Override public String getType() { return \"普通蛋糕\"; } @Override public int getPrice() { return 20; } } 抽象装饰器（Decorator）：Concrete Component的装饰器，一般是一个抽象类，有一个Component类型的成员变量，在构造函数中赋值，强制其子类按其构造方式接收一个Component，如果不需要实现许多装饰器，可以省略该类。 public abstract class CakeDecorator implements Cake { private Cake cake; public CakeDecorator(Cake cake) { this.cake = cake; } @Override public String getType() { return cake.getType(); } @Override public int getPrice() { return cake.getPrice(); } } 具体装饰器（Concrete Decorator）：继承Decorator类，扩展Component的功能。 public class FruitCakeDecorator extends CakeDecorator { public FruitCakeDecorator(Cake cake) { super(cake); } @Override public String getType() { return super.getType() + \"水果\"; } @Override public int getPrice() { return super.getPrice() + 10; } } public class IceCreamCakeDecorator extends CakeDecorator { public IceCreamCakeDecorator(Cake cake) { super(cake); } @Override public String getType() { return super.getType() + \"冰激凌\"; } @Override public int getPrice() { return super.getPrice() + 15; } } 调用示例 Cake cake = new BaseCake(); System.err.println(cake.getType() + \":\" + cake.getPrice()); // 普通蛋糕:20 cake = new IceCreamCakeDecorator(cake); System.err.println(cake.getType() + \":\" + cake.getPrice()); // 普通蛋糕+冰淇淋:35 cake = new FruitCakeDecorator(cake); System.err.println(cake.getType() + \":\" + cake.getPrice()); // 普通蛋糕+冰淇淋+水果:45 与继承的区别 如果是继承，要满足以上场景需要冰淇淋蛋糕，冰淇淋水果蛋糕两个子类，如果这时候需要个水果蛋糕，就得加一个子类，对于普通蛋糕上可扩展项越多，子类将会成几何数增多，而装饰器与扩展项的关系则是1对1。 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-10 18:11:56 "},"designpatterns/structure/proxy.html":{"url":"designpatterns/structure/proxy.html","title":"代理","keywords":"","body":"组成 抽象主题：声明方法，由真实主题与代理实现具体逻辑，是接口/抽象类 public interface ISubject { void request(); } 真实主题：被代理类，在实现抽象主题声明的方法里做了具体的逻辑处理 public class RealSubject implements ISubject { public void request() { System.out.println(\"real service is called.\"); } } 代理主题：代理类，持有真实主题的引用，在实现抽象主题声明的方法时，在真实主题的逻辑处理前后增加一些处理逻辑 public class Proxy implements ISubject { private ISubject subject; public Proxy(ISubject subject) { this.subject = subject; } public void request() { before(); subject.request(); after(); } public void before() { System.out.println(\"called before request().\"); } public void after() { System.out.println(\"called after request().\"); } } 静态代理 Proxy proxy = new Proxy(new RealSubject()); proxy.request(); 如上的实现方式便是静态代理，通常只代理一个明确的类 动态代理 JDK代理 示例 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class JdkProxy implements InvocationHandler { private ISubject target; public ISubject getInstance(ISubject target) { this.target = target; Class clazz = target.getClass(); return (ISubject) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(),this); } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { before(); Object result = method.invoke(this.target, args); after(); return result; } public void before() { System.out.println(\"called before request().\"); } public void after() { System.out.println(\"called after request().\"); } } JdkProxy proxy = new JdkProxy(); ISubject subject = proxy.getInstance(new RealSubject()); subject.request(); 原理 通过字节码重组，重新生成对象(JDK有一个规范，classpath下$开头的.class文件都是自动生成的)来代替原始的被代理对象，新的对象继承了Proxy类并实现了ISubject接口，同时重写了request等方法，在静态块中用反射获取了被代理对象的所有方法且保存了它们的引用，在重写的方法中用反射调用被代理对象的方法 获取被代理对象的引用，并通过反射获取其所有接口 重新生成一个新的实现了被代理对象所有接口的类 编译成.class文件并加载到JVM中 import java.lang.reflect.*; public final class $Proxy0 extends Proxy implements ISubject { public $Proxy0(InvocationHandler invocationhandler) { super(invocationhandler); } public final boolean equals(Object obj) { try { return ((Boolean)super.h.invoke(this, m1, new Object[] {obj})).booleanValue(); } catch(Error _ex) { } catch(Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final void request() { try { super.h.invoke(this, m3, null); return; } catch(Error _ex) { } catch(Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final String toString() { try { return (String)super.h.invoke(this, m2, null); } catch(Error _ex) { } catch(Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final int hashCode() { try { return ((Integer)super.h.invoke(this, m0, null)).intValue(); } catch(Error _ex) { } catch(Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } private static Method m1; private static Method m3; private static Method m2; private static Method m0; static { try { m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] {Class.forName(\"java.lang.Object\")}); m3 = Class.forName(\"com.learn.designpatterns.proxy.RealSubject\").getMethod(\"request\", new Class[0]); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); } catch(NoSuchMethodException nosuchmethodexception) { throw new NoSuchMethodError(nosuchmethodexception.getMessage()); } catch(ClassNotFoundException classnotfoundexception) { throw new NoClassDefFoundError(classnotfoundexception.getMessage()); } } } Cglib代理 被代理对象不需要实现接口,会忽略被代理对象final修饰的方法， 示例 import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CglibProxy implements MethodInterceptor { public Object getInstance(Class clazz) throws Exception { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); } public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { //业务的增强 before(); Object obj = methodProxy.invokeSuper(o,objects); after(); return obj; } public void before() { System.out.println(\"called before request().\"); } public void after() { System.out.println(\"called after request().\"); } } RealSubject subject = (RealSubject)new CglibProxy().getInstance(RealSubject.class); subject.request(); 原理 在new CglibProxy前添加System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/Users/cw/desktop/cglib_proxy_class/\");到cglib_proxy_class目录下可以看到cglib重新生成了3个对象，其中一个对象继承了被代理类即代理类，另外两个继承了FastClass类，这两个不是跟代理类一起生成的，而是在第一次执行MethodProxy的invoke()或 invokeSuper()方法时生成的。 CGLib执行代理方法的效率之所以比JDK的高，是因为CGlib采用了 FastClass机制：为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法分配一个index(int类型，供FastClass直接定位要调用的方法并直接进行调用)，省去了反射调用，所以调用效率比JDK代理通过反射调用高。 import java.lang.reflect.Method; import net.sf.cglib.core.ReflectUtils; import net.sf.cglib.core.Signature; import net.sf.cglib.proxy.*; public class RealSubject$$EnhancerByCGLIB$$3feeb52a extends RealSubject implements Factor { ... // 代理方法(methodProxy.invokeSuper()方法会调用) final void CGLIB$request$0() { super.request(); } //被代理方法(methodProxy.invoke()方法会调用，这就是为什么在拦截器中调用 methodProxy.invoke 会发生死循环，一直在调用拦截器） public final void request() { MethodInterceptor var10000 = this.CGLIB$CALLBACK_0; if (this.CGLIB$CALLBACK_0 == null) { CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_0; } if (var10000 != null) { var10000.intercept(this, CGLIB$request$0$Method, CGLIB$emptyArgs, CGLIB$request$0$Proxy); } else { super.request(); } } ... } CGLib和JDK动态代理对比 JDK动态代理实现了被代理对象的接口，CGLib代理继承了被代理对象 JDK动态代理和CGLib代理都在运行期生成字节码，JDK动态代理直接写Class 字节码，CGLib代理使用ASM框架写Class字节码，CGlib代理实现更复杂，生成代理类比JDK动态代理效率低 JDK动态代理调用代理方法是通过反射机制调用的，CGLib代理是通过 FastClass机制直接调用方法的，CGLib代理的执行效率更高 静态代理和动态代理的区别 对于静态代理，如果被代理类增加了新的方法，代理类需要同步增加，违反了开闭原则 动态代理采用在运行时动态生成代码的方式，没有对被代理类扩展的限制，遵循开闭原则 若动态代理要对目标类的增强逻辑进行扩展，结合策略模式，只需要新增策略类便可，无需修改代理类的代码 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-06-03 17:06:45 "},"designpatterns/structure/composite.html":{"url":"designpatterns/structure/composite.html","title":"组合","keywords":"","body":"概念 将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口表示，使得客户端无需辨别是哪种节点，直接操作。 组成 抽象根节点： 定义各层次共有的方法和属性 树枝节点：定义自身行为，存储子节点 叶子节点：层次遍历的最小单位 透明式 安全式 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-04-21 18:29:34 "},"designpatterns/structure/bridge.html":{"url":"designpatterns/structure/bridge.html","title":"桥接","keywords":"","body":"桥接 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:38:22 "},"designpatterns/structure/flyweight.html":{"url":"designpatterns/structure/flyweight.html","title":"享元","keywords":"","body":"概念 又称为轻量级模式，是对象池的一种实现。把对象的状态分为内部状态和外部状态，通过共享不变的部分，达到减少对象数量及节约内存的目的。 内部状态与外部状态 内部状态 对象内部不变的属性，比如 需要缓冲池：数据库连接对象中的用户名、密码、地址、驱动 系统中有大量相似的对象：一张票的出发地，目的地，耗时 外部状态 对象会产生变化的属性，比如 需要缓冲池：数据库连接对象中的可以使用，还是尚未被释放 系统中有大量相似的对象：一张票的数量，价格 组成 抽象享元：定义行为的一个接口或抽象类 具体享元：实现抽象享元的具体行为 享元工厂：维护享元对象池（通过数组或集合类） 应用场景 系统中有大量相似对象 需要缓冲池 案例 在源码中的应用 String 参考String常量池 Integer valueOf()做了一个判断，如果入参的值在-128至127之间，则从缓存中取值，否则新建对象，因为这个数据范围内数字是使用最频繁的，为了节省频繁创建对象带来的内存消耗，这里用享元模式来提高性能，同理，Long也是。 private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k = 127; } private IntegerCache() {} } public static Integer valueOf(int i) { if (i >= IntegerCache.low && i Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-04-26 17:49:05 "},"designpatterns/behavioral/strategy.html":{"url":"designpatterns/behavioral/strategy.html","title":"策略","keywords":"","body":"概念 又叫政策模式，用继承和多态解决在同一行为在不同场景下的不同实现，避免了if/else或switch所带来的复杂和臃肿 适用场景 针对同一类型问题，有多种处理方式，且每一种都能独立解决问题 算法需要自由切换且只取其中一种的场景 组成 抽象策略角色（IStrategy）：规定策略或算法的行为 public interface IPayStrategy { void pay(); } 具体策略角色（ConcreteStrategy）：具体的策略或算法实现 public class WeChatPayStrategy implements IPayStrategy { @Override public void pay() { System.out.println(\"微信支付\"); } } public class AliPayStrategy implements IPayStrategy { @Override public void pay() { System.out.println(\"支付宝支付\"); } } public class BankPayStrategy implements IPayStrategy { @Override public void pay() { System.out.println(\"银行支付\"); } } 上下文角色（Context）：用来操作策略或算法，屏蔽客户端对策略或算法的直接访问，封装可能存在的变化，一般结合工厂与单例 public class PayFactory { private static Map map = new HashMap<>(); static { map.put(\"wechat\", new WeChatPayStrategy()); map.put(\"ali\", new AliPayStrategy()); map.put(\"bank\", new BankStrategy()); } public static IPayStrategy getStrategy(String key) { return map.get(key); } } 客户端：调用上下文角色 IPayStrategy aliPay = PayFactory.getStrategy(\"ali\"); aliPay.pay(); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-08-11 19:20:34 "},"designpatterns/behavioral/delegate.html":{"url":"designpatterns/behavioral/delegate.html","title":"委派","keywords":"","body":"概念 负责任务的调用或分配，是一种特殊的静态代理，不属于23种设计模式，经典的使用有双亲委派、Spring的DispatcherServlet 组成 抽象任务角色（Task）：定义任务 public interface IEmployee { void doSomething(); } 具体任务角色（Concrete）：实现具体任务并执行 public class Programmer implements IEmployee { @Override public void doSomething(String task) { System.out.println(\"我擅长编程，我开始做\" + task); } } public class ProjectManager implements IEmployee { @Override public void doSomething(String task) { System.out.println(\"我擅长产品，我开始做\" + task); } } 委派者角色（Delegate）：实现抽象任务角色定义的接口，持有具体角色的引用，在其中决定调用哪个具体任务角色 public class Leader implements IEmployee { private static Map subordinates = new HashMap<>(); static { subordinates.put(\"软件开发\", new Programmer()); subordinates.put(\"原型设计\", new ProjectManager()); } @Override public void doSomething(String task) { IEmployee subordinate = subordinates.get(task); if (subordinate != null) { subordinate.doSomething(task); } } } 实际调用者只持有委派者的引用，给委派者分配任务，委派者再将任务分配下去 String task = \"原型设计\"; new Leader().doSomething(task); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-08-13 20:14:11 "},"designpatterns/behavioral/templatemethod.html":{"url":"designpatterns/behavioral/templatemethod.html","title":"模板方法","keywords":"","body":"模板方法 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:52 "},"designpatterns/behavioral/observer.html":{"url":"designpatterns/behavioral/observer.html","title":"观察者","keywords":"","body":"观察者 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-02-20 17:57:50 "},"designpatterns/behavioral/responsibilitychain.html":{"url":"designpatterns/behavioral/responsibilitychain.html","title":"责任链","keywords":"","body":"责任链 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:37:57 "},"designpatterns/behavioral/command.html":{"url":"designpatterns/behavioral/command.html","title":"命令","keywords":"","body":"命令 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:28:19 "},"designpatterns/behavioral/state.html":{"url":"designpatterns/behavioral/state.html","title":"状态","keywords":"","body":"状态 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:29:11 "},"designpatterns/behavioral/visitor.html":{"url":"designpatterns/behavioral/visitor.html","title":"访问者","keywords":"","body":"访问者 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:30:00 "},"designpatterns/behavioral/memento.html":{"url":"designpatterns/behavioral/memento.html","title":"备忘录","keywords":"","body":"备忘录 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:37:41 "},"designpatterns/behavioral/mediator.html":{"url":"designpatterns/behavioral/mediator.html","title":"中介者","keywords":"","body":"中介者 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:29:34 "},"designpatterns/behavioral/iterator.html":{"url":"designpatterns/behavioral/iterator.html","title":"迭代器","keywords":"","body":"迭代器 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:31:30 "},"designpatterns/behavioral/interpreter.html":{"url":"designpatterns/behavioral/interpreter.html","title":"解释器","keywords":"","body":"解释器 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-03-05 16:30:25 "},"concurrency/threadstate.html":{"url":"concurrency/threadstate.html","title":"线程状态与停止复位","keywords":"","body":"Java的6种线程状态 NEW 线程被构建，但是还没有调用start方法 RUNNABLE JAVA线程把操作系统中的ready和running两种状态统一称为“运行” BLOCKED 运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm 会把当前的线程放入到锁池中 WAITING 等待其他线程的通知或中断 TIMED_WAITING 超时以后自动返回 TERMINATED 运行结束或死亡 操作系统的5种线程状态 new 新建，已占用内存空间和其他系统资源，但还没有开始执行 ready 开始执行，等待系统调度分配CPU使用权 running 线程获得了CPU使用权，正在执行 waiting 等待/挂起，让出CPU资源给其他线程使用 terminated 运行结束或死亡 线程的终止与复位 终止 线程的终止，并不是简单的通过调用stop方法。虽然API仍然可以调用，但是和其他的线程控制方法如suspend、resume一样都是Deprecated的不建议使用，stop方法在结束一个线程时并不会保证线程的资源正常释放，因此会导致程序可能出现一些不确定的状态。要优雅的去中断一个线程，在线程中提供了一个interrupt方法。当其他线程通过调用当前线程的interrupt方法，表示向当前线程打个招呼，告诉它可以中断线程的执行了，至于什么时候中断，取决于当前线程自己，interrupt本质上是通过unpark方法去随机唤醒一个其他线程并将当前线程的中断标识位设为true。当前线程通过检查自身是否被中断来进行响应，可以通过isInterrupted方法来判断是否被中断。 Thread thread = new Thread(() -> { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"execute\"); } }, \"interruptDemo\"); thread.start(); TimeUnit.SECONDS.sleep(1); thread.interrupt(); 复位 线程中还提供了静态方法Thread.interrupted()对设置中断标识的线程复位。除此以外如sleep/wait/join等方法都会抛出InterruptedException异常，在InterruptedException抛出之前，JVM会先把线程的中断标识位清除，然后才会抛出InterruptedException，这个时候如果调用isInterrupted方法，也会返回 false。 Thread thread = new Thread(() -> { while (!Thread.currentThread().isInterrupted()) { try { System.out.println(\"execute\"); Thread.sleep(1000); } catch (InterruptedException e) { // 主线程调用当前线程的interrupt()会导致抛出该异常，中断标识位被置为了false，此时循环将继续 // 若想结束循环，再次中断 Thread.currentThread().interrupt(); } } }, \"interruptedDemo\"); thread.start(); thread.interrupt(); Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-08-30 19:17:32 "},"oauth2/websecurityconfigureradapter-yu-resourceserverconfigureradapter.html":{"url":"oauth2/websecurityconfigureradapter-yu-resourceserverconfigureradapter.html","title":"WebSecurityConfigurerAdapter与ResourceServerConfigurerAdapter","keywords":"","body":"WebSecurityConfigurerAdapter与ResourceServerConfigurerAdapter 1.1、spring security的过滤器链 spring security自己有一个叫FilterChainProxy代理类，该类实现了servlet接口。FilterChainProxy内部有一个List filterChains,在spring 的体系里有个order值（int型）越小优先级越高，filterChains是一个依据order的降序集合，优先级高的在前面，而SecurityFilterChain是一个接口也是一个chain，每个chain里有若干个filter，在spring security里一个请求只会被一个filter chain进行处理，也就是spring security通过遍历filterChains这个集合时，只要找到能处理该请求（servlet-path匹配，即uri中去掉context-path的部分）的filter chain就不再进行其他的filter chain匹配。 private List filterChains; private List getFilters(HttpServletRequest request) { Iterator var2 = this.filterChains.iterator(); SecurityFilterChain chain; do { if (!var2.hasNext()) { return null; } chain = (SecurityFilterChain)var2.next(); } while(!chain.matches(request)); // 找到匹配的chain后终止循环 return chain.getFilters(); } 1.2、二者顺序 默认的WebSecurityConfigurerAdapter的order是100 @Order(100) public abstract class WebSecurityConfigurerAdapter 而ResourceServerConfigurerAdapter实现类的@EnableResourceServer里导入了ResourceServerConfiguration， @Import({ResourceServerConfiguration.class}) public @interface EnableResourceServer { 该类里定义了order为3 public class ResourceServerConfiguration extends WebSecurityConfigurerAdapter implements Ordered { private int order = 3; 所以ResourceServerConfigurerAdapter的实现类优先级比另外一个的更高，在请求匹配的情况下以它为准，而WebSecurityConfigurerAdapter的实现类会失效。 如果想让WebSecurityConfigurerAdapter比ResourceServerConfigurerAdapter优先级高的话，只须要让前者的@Order值比后者的@Order值更小就行了。 @Order(1) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { 每声明一个*Adapter的实现类，都会产生一个filterChain。前面讲到一个request（匹配url）只能被一个filterChain处理，所以有二个Adapter的时候，在请求都匹配的情况下，优先级较低的会失效。 1.3、二者同时生效 根本在于让不同的Adapter匹配不同request（url） 实现时将细粒度较粗的优先级设低 @EnableWebSecuritypublic class MultiHttpSecurityConfig { @Configuration @EnableResourceServer public static class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .antMatcher(\"/auth/**\") // 指定该Adapter只处理/auth/**的请求 .authorizeRequests() // 对该路径做更细的权限控制 .antMatchers(\"/admin/**\").hasAuthority(\"ROLE_ADMIN\") .antMatchers(\"/user/**\").hasAuthority(\"ROLE_USER\") .anyRequest().authenticated(); } } @Configuration public static class WebSecurityConfig extends WebSecurityConfigurerAdapter { protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() // 因为它的顺序在上面的Adapter之后，所以实际是对/auth/**外的所有请求做权限的控制 .antMatchers(\"/actutor/**\").permitAll( .antMatchers(\"/admin/**\").hasAuthority(\"ROLE_ADMIN\") .anyRequest() .authenticated(); } } } 1.4、Tips spring security集成Oauth2后有个默认的AuthorizationServerSecurityConfiguration，其order为0，该类是对/oauth/token、/oauth/token_key、/oauth/check_token三个url做处理的 protected void configure(HttpSecurity http) throws Exception { AuthorizationServerSecurityConfigurer configurer = new AuthorizationServerSecurityConfigurer(); FrameworkEndpointHandlerMapping handlerMapping = this.endpoints.oauth2EndpointHandlerMapping(); http.setSharedObject(FrameworkEndpointHandlerMapping.class, handlerMapping); this.configure(configurer); http.apply(configurer); String tokenEndpointPath = handlerMapping.getServletPath(\"/oauth/token\"); String tokenKeyPath = handlerMapping.getServletPath(\"/oauth/token_key\"); String checkTokenPath = handlerMapping.getServletPath(\"/oauth/check_token\"); if (!this.endpoints.getEndpointsConfigurer().isUserDetailsServiceOverride()) { UserDetailsService userDetailsService = (UserDetailsService)http.getSharedObject(UserDetailsService.class); this.endpoints.getEndpointsConfigurer().userDetailsService(userDetailsService); } // /oauth/token的权限写死为fullyAuthenticated // /oauth/token_key、/oauth/check_token的权限则是可配的，默认为denyAll，可在实现AuthorizationServerConfigurerAdapter的配置类中修改 ((RequestMatcherConfigurer)((HttpSecurity)((AuthorizedUrl)((AuthorizedUrl)((AuthorizedUrl)http.authorizeRequests().antMatchers(new String[]{tokenEndpointPath})).fullyAuthenticated().antMatchers(new String[]{tokenKeyPath})).access(configurer.getTokenKeyAccess()).antMatchers(new String[]{checkTokenPath})).access(configurer.getCheckTokenAccess()).and()).requestMatchers().antMatchers(new String[]{tokenEndpointPath, tokenKeyPath, checkTokenPath})).and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); http.setSharedObject(ClientDetailsService.class, this.clientDetailsService); } public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception { oauthServer .tokenKeyAccess(\"permitAll()\") .checkTokenAccess(\"isAuthenticated()\"); } } Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2019-12-31 15:58:40 "},"other/StringConstantPool.html":{"url":"other/StringConstantPool.html","title":"String常量池","keywords":"","body":"String s1 = \"hello\"; String s2 = \"hello\"; String s3 = \"he\" + \"llo\"; String s4 = \"he\" + new String(\"llo\"); String s5 = new String(\"hello\"); String s6 = s5.intern(); String s7 = \"he\"; String s8 = \"llo\"; String s9 = s7 + s8; System.out.println(s1 == s2); // true // 以字面量的形式创建String变量时，JVM会在编译期间就把该字面量\"hello\"放到字符串常量池中，后续再以字面量的形式创建\"hello\"变量时,直接返回该字面量在字符串常量池中的引用，所以s1==s2。 System.out.println(s1 == s3); // true // \"he\" + \"llo\"在编译期间JVM会将其拼接为\"hello\"，如果常量池中没有，就放入字符串常量池中，否则返回该字面量在字符串常量池中的引用，并不会将\"he\"和\"llo\"放入字符串常量池中，所以s1==s3。 System.out.println(s1 == s4); // false // new String(\"llo\")创建了两个对象，\"llo\"存于字符串常量池，new String(\"llo\")存于堆，\"he\" + new String(\"llo\")两个对象的相加编译器不会优化，相加的结果存于堆，所以s1!=s4。 System.out.println(s1 == s9); // false // s7 + s8两个对象的相加编译器不会优化，相加的结果存于堆，所以s1!=s9 System.out.println(s4 == s5); // false // s4和s5是堆中两个不同的对象，所以s4!=s5。 System.out.println(s1 == s6); // true // intern()能使一个位于堆中的字符串在运行期间动态的加入到字符串常量池中（字符串常量池的内容是程序启动的时候就加载进内存了），如果字符串常量池中有该对象对应的字面量，就返回该字面量在字符串常量池中的引用，否则在字符串常量池中创建该对象对应的字面量，将该对象的引用作为该字面量在字符串常量池中的引用并返回。 String s10 = new String(\"hello\") + new String(\"h\"); String s11 = s10.intern(); String s12 = \"helloh\"; System.out.println(s13 == s14); // 生成了5个对象：字符串常量池中的\"hello\"和\"h\",两个在堆中的对象new String(\"hello\")和new String(\"h\")以及它们相加后的对象，intern将\"helloh\"放入字符串常量池中，并将相加后的对象的引用作为字符串常量池中\"helloh\"的引用，所以s14和s13是同一个引用，所以s13==s14。 String s13 = new StringBuilder(\"test\").append(\"this\").toString(); System.out.println(s13 == s13.intern()); // true // s13.intern()将s13的引用作为字面量\"testthis\"的引用存到了常量池 Copyright © bukeyan 2020 all right reserved，powered by Gitbook该文章修改时间： 2020-04-21 17:29:05 "}}